# Task: I'll create a concise example demonstrating DuckDB's recursive CTE capabilities for generating a hierarchical organizational structure:

```python
import duckdb

con = duckdb.connect()

# Recursive CTE to explore organizational hierarchy
rel = con.query('''
WITH RECURSIVE org_hierarchy(employee_id, name, manager_id, level) AS (
    SELECT employee_id, name, manager_id, 0
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.employee_id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN org_hierarchy h ON e.manager_id = h.employee_id
)
SELECT * FROM org_hierarchy
''')

print(rel.execute().fetchall())
```

This example demonstrates a recursive CTE for traversing an organizational hierarchy, showing employee relationships and depth levels.

## Step 1: I'll create a concise example demonstrating DuckDB's recursive CTE capabilities for generating a hierarchical organizational structure:

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create employee hierarchy table
conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'CEO', NULL),
    (2, 'CTO', 1),
    (3, 'CFO', 1),
    (4, 'Senior Engineer', 2),
    (5, 'Junior Engineer', 4);

-- Recursive CTE to trace organizational hierarchy
WITH RECURSIVE org_hierarchy AS (
    SELECT employee_id, name, manager_id, 0 AS depth
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.employee_id, e.name, e.manager_id, oh.depth + 1
    FROM employees e
    JOIN org_hierarchy oh ON e.manager_id = oh.employee_id
)

SELECT * FROM org_hierarchy ORDER BY depth, employee_id;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates recursive CTE for traversing organizational hierarchy, showing employee reporting structure with hierarchical depth tracking
## Step 2: ```python

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Creating sales tracking with quarterly window function analysis
conn.execute('''
CREATE TABLE sales (
    product_id INTEGER,
    quarter VARCHAR,
    total_revenue DECIMAL(10,2)
);

INSERT INTO sales VALUES
    (1, 'Q1', 1000.00),
    (1, 'Q2', 1200.00),
    (1, 'Q3', 1500.00),
    (1, 'Q4', 1800.00);

-- Calculate cumulative and percent change across quarters
SELECT 
    product_id, 
    quarter, 
    total_revenue,
    SUM(total_revenue) OVER (PARTITION BY product_id ORDER BY quarter) as cumulative_revenue,
    (total_revenue - LAG(total_revenue) OVER (PARTITION BY product_id ORDER BY quarter)) / 
        LAG(total_revenue) OVER (PARTITION BY product_id ORDER BY quarter) * 100 as revenue_percent_change
FROM sales
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates window functions in DuckDB by calculating cumulative revenue and quarter-over-quarter percent revenue change, showcasing advanced analytical capabilities with partitioning and window frame calculations.
## Step 3: import duckdb

**Generated by**: Anthropic

```python
import duckdb

# Create and query a geospatial table with point data
conn = duckdb.connect(':memory:')

conn.sql('''
CREATE TABLE locations (
    id INTEGER,
    name VARCHAR,
    latitude DOUBLE,
    longitude DOUBLE
);

INSERT INTO locations VALUES
    (1, 'New York', 40.7128, -74.0060),
    (2, 'Los Angeles', 34.0522, -118.2437),
    (3, 'Chicago', 41.8781, -87.6298);

-- Calculate distance between points using Haversine formula
WITH distances AS (
    SELECT 
        l1.name AS origin,
        l2.name AS destination,
        ROUND(6371 * 2 * ASIN(
            SQRT(POW(SIN((l1.latitude - l2.latitude) * PI() / 360), 2) +
            COS(l1.latitude * PI() / 180) * COS(l2.latitude * PI() / 180) *
            POW(SIN((l1.longitude - l2.longitude) * PI() / 360), 2))
        ), 2) AS distance_km
    FROM locations l1
    CROSS JOIN locations l2
    WHERE l1.id != l2.id
)

SELECT * FROM distances ORDER BY distance_km;
''').show()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates geospatial distance calculation using Haversine formula in a cross join, showcasing DuckDB's advanced mathematical and spatial query capabilities
## Step 4: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create and analyze sensor performance data
conn.sql('''
CREATE TABLE sensor_readings (
    sensor_id INTEGER,
    reading_time TIMESTAMP,
    temperature FLOAT,
    humidity FLOAT
);

INSERT INTO sensor_readings VALUES
    (1, '2023-01-01 10:00:00', 22.5, 45.3),
    (1, '2023-01-01 11:00:00', 23.1, 46.2),
    (2, '2023-01-01 10:00:00', 19.8, 55.7),
    (2, '2023-01-01 11:00:00', 20.3, 54.9);

-- Calculate moving average and standard deviation of temperature
SELECT
    sensor_id,
    reading_time,
    temperature,
    AVG(temperature) OVER (PARTITION BY sensor_id ORDER BY reading_time ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS moving_avg,
    STDDEV(temperature) OVER (PARTITION BY sensor_id) AS temperature_variation
FROM sensor_readings
''').show()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates DuckDB's window functions by analyzing sensor data, calculating moving averages and standard deviation across sensor readings
## Step 5: # Recursive CTE to explore organizational hierarchy

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create employee hierarchy table
conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1),
    (4, 'David', 2),
    (5, 'Eve', 4);

-- Recursive CTE to trace complete organizational hierarchy
WITH RECURSIVE org_hierarchy AS (
    SELECT employee_id, name, manager_id, 0 AS depth
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.employee_id, e.name, e.manager_id, oh.depth + 1
    FROM employees e
    JOIN org_hierarchy oh ON e.manager_id = oh.employee_id
)

SELECT * FROM org_hierarchy ORDER BY depth, employee_id;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates a recursive Common Table Expression (CTE) to explore an organizational hierarchy, showing employee relationships, reporting structure, and depth in the organizational tree
## Step 6: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a product catalog with inventory tracking
conn.sql('''
CREATE TABLE products (
    product_id INTEGER PRIMARY KEY,
    name VARCHAR,
    category VARCHAR,
    price DECIMAL(10,2)
);

CREATE TABLE inventory (
    product_id INTEGER,
    warehouse_id INTEGER,
    stock_quantity INTEGER
);

INSERT INTO products VALUES
    (1, 'Laptop', 'Electronics', 999.99),
    (2, 'Smartphone', 'Electronics', 599.99),
    (3, 'Desk Chair', 'Furniture', 249.99);

INSERT INTO inventory VALUES
    (1, 1, 50),
    (1, 2, 30),
    (2, 1, 75),
    (3, 2, 20);

-- Find total inventory and average price per category
SELECT 
    p.category,
    SUM(i.stock_quantity) as total_stock,
    AVG(p.price) as avg_category_price
FROM products p
JOIN inventory i ON p.product_id = i.product_id
GROUP BY p.category
''').show()

```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates a multi-table join with inventory and product data, using aggregation to compute total stock and average price per category
## Step 7: WITH RECURSIVE org_hierarchy(employee_id, name, manager_id, level) AS (

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create complex organizational hierarchy
conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER,
    salary DECIMAL(10,2)
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL, 150000),
    (2, 'Bob', 1, 100000),
    (3, 'Charlie', 1, 95000),
    (4, 'David', 2, 75000),
    (5, 'Eve', 2, 70000);

-- Recursive hierarchy with salary aggregation
WITH RECURSIVE org_hierarchy(employee_id, name, manager_id, level, total_team_salary) AS (
    SELECT 
        employee_id, 
        name, 
        manager_id, 
        0 AS level, 
        salary AS total_team_salary
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT 
        e.employee_id, 
        e.name, 
        e.manager_id, 
        oh.level + 1, 
        oh.total_team_salary + e.salary
    FROM employees e
    JOIN org_hierarchy oh ON e.manager_id = oh.employee_id
)

SELECT * FROM org_hierarchy ORDER BY level, employee_id;''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates a recursive CTE that traces organizational hierarchy while calculating cumulative team salary, showing nested management relationships and total compensation per management branch.
## Step 8: SELECT employee_id, name, manager_id, 0

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1);

SELECT employee_id, name, manager_id, 0 AS level
FROM employees;
''')
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates selecting basic employee details with a static zero-level column, useful for initializing hierarchical queries or adding a constant column to a resultset
## Step 9: FROM employees

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1);

SELECT * FROM employees;
''')
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Creates an in-memory DuckDB table with employees, inserting sample data and selecting all records to demonstrate basic table creation and querying.
## Step 10: WHERE manager_id IS NULL

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1);

SELECT * FROM employees WHERE manager_id IS NULL;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: This code demonstrates filtering for top-level employees (those without a manager) using the WHERE manager_id IS NULL condition in a DuckDB SQL query. It creates an employees table, inserts sample data, and retrieves only the root/top-level employee record.
## Step 11: UNION ALL

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create two tables for UNION ALL demonstration
conn.execute('''
CREATE TABLE sales_2022 (product VARCHAR, revenue DECIMAL(10,2));
CREATE TABLE sales_2023 (product VARCHAR, revenue DECIMAL(10,2));

INSERT INTO sales_2022 VALUES
    ('Laptop', 500000.00),
    ('Smartphone', 350000.00);

INSERT INTO sales_2023 VALUES
    ('Laptop', 600000.00),
    ('Tablet', 250000.00);

-- Combine sales data from two years using UNION ALL
SELECT product, revenue, '2022' as year FROM sales_2022
UNION ALL
SELECT product, revenue, '2023' as year FROM sales_2023;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates UNION ALL by combining sales data from two tables without removing duplicates, preserving all rows and adding a year column to distinguish sources
## Step 12: SELECT e.employee_id, e.name, e.manager_id, h.level + 1

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1);

WITH RECURSIVE org_hierarchy AS (
    SELECT employee_id, name, manager_id, 0 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.employee_id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN org_hierarchy h ON e.manager_id = h.employee_id
)

SELECT * FROM org_hierarchy;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates a recursive common table expression (CTE) for calculating organizational hierarchy levels, using the recursive join condition to systematically increment hierarchy depth.
## Step 13: FROM employees e

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    department VARCHAR,
    salary DECIMAL(10,2)
);

INSERT INTO employees VALUES
    (1, 'Alice', 'Engineering', 85000.50),
    (2, 'Bob', 'Sales', 72000.75),
    (3, 'Charlie', 'Engineering', 92000.25);

SELECT * FROM employees e
WHERE e.department = 'Engineering';
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates a basic table creation, insertion, and filtering query using the FROM clause with table alias 'e', focusing on selecting employees from the Engineering department
## Step 14: JOIN org_hierarchy h ON e.manager_id = h.employee_id

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1);

WITH RECURSIVE org_hierarchy AS (
    SELECT employee_id, name, manager_id, 0 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.employee_id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN org_hierarchy h ON e.manager_id = h.employee_id
)

SELECT * FROM org_hierarchy;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: This example demonstrates a recursive Common Table Expression (CTE) that maps an organizational hierarchy using a self-join between the 'employees' table and the recursive 'org_hierarchy'. The JOIN condition `e.manager_id = h.employee_id` links each employee to their manager in the hierarchy, allowing traversal of the organizational structure.
## Step 15: )

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE orders (
    order_id INTEGER PRIMARY KEY,
    customer_id INTEGER,
    total_amount DECIMAL(10,2),
    order_date DATE
);

INSERT INTO orders VALUES
    (1, 101, 250.50, '2023-01-15'),
    (2, 102, 175.25, '2023-02-20'),
    (3, 101, 300.75, '2023-03-10');

-- Find customer spending with window functions
SELECT 
    customer_id, 
    total_amount,
    order_date,
    SUM(total_amount) OVER (PARTITION BY customer_id) as total_customer_spend,
    FIRST_VALUE(order_date) OVER (PARTITION BY customer_id ORDER BY order_date) as first_order_date
FROM orders
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates advanced window functions in DuckDB by calculating total customer spending and identifying first order date using OVER and window partitioning
## Step 16: SELECT * FROM org_hierarchy

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1);

WITH RECURSIVE org_hierarchy AS (
    SELECT employee_id, name, manager_id, 0 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.employee_id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN org_hierarchy h ON e.manager_id = h.employee_id
)

SELECT * FROM org_hierarchy;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: This code demonstrates a recursive Common Table Expression (CTE) to generate an organizational hierarchy by traversing employee relationships starting from top-level managers.
## Step 17: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create and analyze international sales data
conn.sql('''
CREATE TABLE sales (
    region VARCHAR,
    product VARCHAR,
    revenue DECIMAL(10,2),
    sales_quarter VARCHAR
);

INSERT INTO sales VALUES
    ('Europe', 'Laptop', 500000.50, 'Q1'),
    ('North America', 'Smartphone', 750000.75, 'Q1'),
    ('Asia', 'Tablet', 350000.25, 'Q2');

-- Perform multi-dimensional rollup of global sales
SELECT 
    COALESCE(region, 'Total') AS sales_region,
    COALESCE(product, 'All Products') AS product_category,
    COALESCE(sales_quarter, 'Yearly') AS time_period,
    SUM(revenue) AS total_revenue
FROM sales
GROUP BY ROLLUP(region, product, sales_quarter)
ORDER BY total_revenue DESC;
''').show()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates DuckDB's ROLLUP capability to generate multi-dimensional aggregation of sales data across regions, products, and quarters, providing comprehensive hierarchical summary views.
## Step 18: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create table and insert sample data
conn.sql('''
CREATE TABLE temperatures (
    city VARCHAR,
    date DATE,
    temp_celsius FLOAT
);

INSERT INTO temperatures VALUES
    ('New York', '2023-07-01', 28.5),
    ('New York', '2023-07-02', 29.1),
    ('Chicago', '2023-07-01', 25.3),
    ('Chicago', '2023-07-02', 26.7);
''')

# Complex windowing with inter-city temperature comparisons
rel = conn.sql('''
SELECT 
    city, 
    date, 
    temp_celsius,
    AVG(temp_celsius) OVER (PARTITION BY city ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as moving_avg,
    temp_celsius - AVG(temp_celsius) OVER (PARTITION BY city) as deviation_from_mean
FROM temperatures
''')

print(rel.execute().fetchall())
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates advanced windowing functions in DuckDB by calculating moving averages and temperature deviations across multiple cities
## Step 19: ```

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create time series table tracking inventory changes
conn.sql('''
CREATE TABLE inventory_log (
    product_id INTEGER,
    change_time TIMESTAMP,
    quantity_change INTEGER
);

INSERT INTO inventory_log VALUES
    (1, '2023-07-01 10:00:00', 50),
    (1, '2023-07-01 11:00:00', -10),
    (1, '2023-07-01 12:00:00', 20);

-- Calculate cumulative inventory and rate of change
SELECT
    product_id,
    change_time,
    quantity_change,
    SUM(quantity_change) OVER (PARTITION BY product_id ORDER BY change_time) as cumulative_inventory,
    quantity_change - LAG(quantity_change) OVER (PARTITION BY product_id ORDER BY change_time) as inventory_delta
FROM inventory_log
''').show()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates DuckDB's window functions for tracking inventory changes over time, calculating cumulative inventory and tracking delta between time points using windowing techniques.
## Step 20: This example demonstrates a recursive CTE for traversing an organizational hierarchy, showing employee relationships and depth levels.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE employees (
    employee_id INTEGER PRIMARY KEY,
    name VARCHAR,
    manager_id INTEGER
);

INSERT INTO employees VALUES
    (1, 'Alice', NULL),
    (2, 'Bob', 1),
    (3, 'Charlie', 1);

WITH RECURSIVE org_hierarchy AS (
    SELECT employee_id, name, manager_id, 0 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.employee_id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN org_hierarchy h ON e.manager_id = h.employee_id
)

SELECT * FROM org_hierarchy;
''').fetchall()
```

**Result**: [('Phone', 'South', Decimal('3200.75'), Decimal('3200.75')), ('Laptop', 'West', Decimal('4500.60'), Decimal('4500.60')), ('Laptop', 'North', Decimal('5000.50'), Decimal('5000.50')), ('Tablet', 'East', Decimal('2100.25'), Decimal('2100.25'))]

**Explanation**: Demonstrates a recursive Common Table Expression (CTE) for traversing an organizational hierarchy. The query starts with root-level employees (no manager), then recursively joins subsequent levels, tracking employee relationships and hierarchy depth.
