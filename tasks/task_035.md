# Task: ```python
import duckdb

con = duckdb.connect()

# Transform numeric array by squaring values
rel = con.query('''
SELECT array_transform([1, 2, 3, 4], x -> x * x) as squared_array
''')

print(rel.execute().fetchall())
```

This concise example demonstrates DuckDB's array_transform function for direct list transformation, showing its functional programming capabilities within SQL queries.

## Step 1: ```python

**Generated by**: Anthropic

```python
import duckdb

# Create an in-memory database and table
conn = duckdb.connect(':memory:')
conn.execute('CREATE TABLE users (id INT, name VARCHAR, age INT)')

# Insert sample data
conn.executemany('INSERT INTO users VALUES (?, ?, ?)', [
    (1, 'Alice', 30),
    (2, 'Bob', 25),
    (3, 'Charlie', 35)
])

# Perform a window function to rank users by age
result = conn.execute('''
    SELECT 
        name, 
        age, 
        RANK() OVER (ORDER BY age DESC) as age_rank
    FROM users
''').fetchall()

print(result)
```

**Result**: [('Charlie', 35, 1), ('Alice', 30, 2), ('Bob', 25, 3)]

**Explanation**: Demonstrates creating an in-memory DuckDB database, inserting data, and using a window function to rank users by age, showcasing DuckDB's SQL capabilities and window function support.
## Step 2: import duckdb

**Generated by**: Anthropic

```python
import duckdb

# Create in-memory database and table
conn = duckdb.connect(':memory:')
conn.execute('CREATE TABLE sales (product VARCHAR, quantity INT, price DECIMAL(10,2))')

# Insert sample sales data
conn.executemany('INSERT INTO sales VALUES (?, ?, ?)', [
    ('Laptop', 50, 999.99),
    ('Phone', 100, 499.50),
    ('Tablet', 75, 299.75)
])

# Calculate total revenue per product using SQL aggregation
result = conn.execute('''
    SELECT 
        product, 
        SUM(quantity * price) as total_revenue,
        AVG(price) as avg_price
    FROM sales
    GROUP BY product
    ORDER BY total_revenue DESC
''').fetchall()

print(result)
```

**Result**: [('Laptop', Decimal('49999.50'), 999.99), ('Phone', Decimal('49950.00'), 499.5), ('Tablet', Decimal('22481.25'), 299.75)]

**Explanation**: Demonstrates creating an in-memory database, inserting sales data, and performing SQL aggregation to calculate total revenue and average price per product using DuckDB's SQL capabilities.
## Step 3: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

# Demonstrate lateral join with subquery generation
conn = duckdb.connect(':memory:')

# Create tables with related data
conn.execute('CREATE TABLE departments (dept_id INT, dept_name VARCHAR)')
conn.execute('CREATE TABLE employees (emp_id INT, name VARCHAR, dept_id INT, salary DECIMAL(10,2))')

conn.executemany('INSERT INTO departments VALUES (?, ?)', [
    (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing')
])

conn.executemany('INSERT INTO employees VALUES (?, ?, ?, ?)', [
    (101, 'Alice', 1, 5000.00),
    (102, 'Bob', 2, 6500.50),
    (103, 'Charlie', 2, 7200.75)
])

# Use lateral join to generate employee salary ranges per department
result = conn.execute('''
    SELECT 
        d.dept_name, 
        e.name, 
        e.salary,
        FIRST_VALUE(e.salary) OVER (PARTITION BY d.dept_id ORDER BY e.salary) as min_salary,
        LAST_VALUE(e.salary) OVER (PARTITION BY d.dept_id ORDER BY e.salary) as max_salary
    FROM departments d
    LEFT JOIN LATERAL (
        SELECT * FROM employees WHERE dept_id = d.dept_id
    ) e ON TRUE
''').fetchall()

print(result)
```

**Result**: [('Marketing', None, None, None, None), ('Sales', 'Alice', Decimal('5000.00'), Decimal('5000.00'), Decimal('5000.00')), ('Engineering', 'Bob', Decimal('6500.50'), Decimal('6500.50'), Decimal('6500.50')), ('Engineering', 'Charlie', Decimal('7200.75'), Decimal('6500.50'), Decimal('7200.75'))]

**Explanation**: Demonstrates a lateral join with window functions to generate salary ranges per department, showing DuckDB's advanced joining and windowing capabilities.
## Step 4: # Transform numeric array by squaring values

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create array column and transform values
result = conn.execute('''
    SELECT [1, 2, 3, 4, 5] as original_array,
           array_transform([1, 2, 3, 4, 5], x -> x * x) as squared_array
''').fetchall()

print(result)
```

**Result**: [([1, 2, 3, 4, 5], [1, 4, 9, 16, 25])]

**Explanation**: Demonstrates DuckDB's array_transform() function to apply a squaring transformation to a numeric array inline using a lambda expression.
## Step 5: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

# Create in-memory database
conn = duckdb.connect(':memory:')

# Create orders table with different categories
conn.execute('CREATE TABLE orders (order_id INT, category VARCHAR, amount DECIMAL(10,2))')

# Insert sample order data
conn.executemany('INSERT INTO orders VALUES (?, ?, ?)', [
    (1, 'Electronics', 500.00),
    (2, 'Clothing', 250.50),
    (3, 'Electronics', 750.25),
    (4, 'Home', 150.75)
])

# Demonstrate conditional aggregation with FILTER clause
result = conn.execute('''
    SELECT 
        category,
        SUM(amount) as total_revenue,
        SUM(amount) FILTER (WHERE amount > 500) as high_value_revenue
    FROM orders
    GROUP BY category
    ORDER BY total_revenue DESC
''').fetchall()

print(result)
```

**Result**: [('Electronics', Decimal('1250.25'), Decimal('750.25')), ('Clothing', Decimal('250.50'), None), ('Home', Decimal('150.75'), None)]

**Explanation**: This example demonstrates advanced aggregation in DuckDB using the FILTER clause to conditionally calculate total revenue, allowing precise subset calculations within a single query.
## Step 6: SELECT array_transform([1, 2, 3, 4], x -> x * x) as squared_array

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute('SELECT array_transform([1, 2, 3, 4], x -> x * x) as squared_array').fetchall()
print(result)
```

**Result**: [([1, 4, 9, 16],)]

**Explanation**: Demonstrates DuckDB's array_transform function to square each element of an input array using a lambda expression, showing functional array manipulation capabilities
## Step 7: ''')

**Generated by**: Anthropic

```python
import duckdb

# Connect to in-memory database
conn = duckdb.connect(':memory:')

# Create and populate recursive CTE for generating number series
result = conn.execute('''
WITH RECURSIVE
  number_series(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM number_series WHERE n < 10
  )
SELECT * FROM number_series
''').fetchall()

print(result)
```

**Result**: [(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,)]

**Explanation**: Demonstrates DuckDB's recursive CTE capability to generate a sequential number series from 1 to 10, showcasing the ability to create self-referential queries that generate data dynamically.
## Step 8: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
conn.execute('CREATE TABLE test_table (id INT, value VARCHAR)')
conn.executemany('INSERT INTO test_table VALUES (?, ?)', [(1, 'a'), (2, 'b'), (3, 'c')])

rel = conn.table('test_table').filter('id > 1')
print(rel.execute().fetchall())
```

**Result**: [(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,)]

**Explanation**: Creates an in-memory table with test data, establishes a relational query that filters rows where id is greater than 1, and then executes and prints the resulting rows.
## Step 9: ```

**Generated by**: Anthropic

```python
import duckdb

# Create in-memory database and generate product sales analysis
conn = duckdb.connect(':memory:')

# Create sales table with timestamps
conn.execute('CREATE TABLE product_sales (product VARCHAR, sale_timestamp TIMESTAMP, quantity INT, price DECIMAL(10,2))')

# Insert sample time-based sales data
conn.executemany('INSERT INTO product_sales VALUES (?, ?, ?, ?)', [
    ('Laptop', '2023-01-15 10:30:00', 5, 999.99),
    ('Phone', '2023-01-15 11:45:00', 10, 499.50),
    ('Tablet', '2023-01-16 09:20:00', 7, 299.75)
])

# Perform time-window aggregation and ranking
result = conn.execute('''
    SELECT 
        product,
        DATE_TRUNC('day', sale_timestamp) as sale_day,
        SUM(quantity * price) as daily_revenue,
        RANK() OVER (ORDER BY SUM(quantity * price) DESC) as revenue_rank
    FROM product_sales
    GROUP BY product, sale_day
''').fetchall()

print(result)
```

**Result**: [('Laptop', datetime.date(2023, 1, 15), Decimal('4999.95'), 1), ('Phone', datetime.date(2023, 1, 15), Decimal('4995.00'), 2), ('Tablet', datetime.date(2023, 1, 16), Decimal('2098.25'), 3)]

**Explanation**: Demonstrates advanced DuckDB features including time-based aggregation, window functions, and timestamp manipulation by analyzing product sales data with daily revenue ranking.
## Step 10: This concise example demonstrates DuckDB's array_transform function for direct list transformation, showing its functional programming capabilities within SQL queries.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Demonstrate array_transform to convert list and apply mathematical operations
result = conn.execute("""
    SELECT 
        [1, 2, 3, 4, 5] as original_list,
        array_transform([1, 2, 3, 4, 5], x -> x * 2) as doubled_list,
        array_transform([1, 2, 3, 4, 5], x -> x % 2 = 0) as is_even_list
""").fetchall()

print(result)
```

**Result**: [([1, 2, 3, 4, 5], [2, 4, 6, 8, 10], [False, True, False, True, False])]

**Explanation**: Demonstrates DuckDB's array_transform function, showing how to apply in-line transformations to lists using lambda-like syntax within SQL queries, including multiplication and boolean checks.
