# Task: I'm ready to generate a concise, targeted DuckDB example. Would you prefer exploration of a specific feature like:

1. Recursive query demonstration
2. Custom aggregate function
3. Temporal/date window function
4. Advanced join technique

I'll craft a small, illustrative implementation focusing on one unique DuckDB capability in the relational API.

## Step 1: I'm ready to generate a concise, targeted DuckDB example. Would you prefer exploration of a specific feature like:

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sample sales data
conn.execute('''
CREATE TABLE sales AS 
SELECT * FROM (
    VALUES 
    (1, 'Electronics', 500.50),
    (2, 'Clothing', 250.75),
    (3, 'Electronics', 1200.00),
    (4, 'Books', 75.25)
) t(sale_id, category, amount)
''')

# Perform window function to rank sales within categories
result = conn.execute('''
SELECT 
    sale_id, 
    category, 
    amount,
    RANK() OVER (PARTITION BY category ORDER BY amount DESC) as category_rank
FROM sales
''').fetchall()

for row in result:
    print(row)
```

**Result**: [(3, 'Electronics', Decimal('1200.00'), 1), (1, 'Electronics', Decimal('500.50'), 2), (4, 'Books', Decimal('75.25'), 1), (2, 'Clothing', Decimal('250.75'), 1)]

**Explanation**: Demonstrates DuckDB's window function capabilities by ranking sales within product categories using RANK() OVER, showing partitioning and ordering in a single query.
## Step 2: 1. Recursive query demonstration

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create employee hierarchy table
conn.execute('''
CREATE TABLE employees (
    employee_id INT,
    name VARCHAR,
    manager_id INT
);

INSERT INTO employees VALUES
(1, 'CEO', NULL),
(2, 'CTO', 1),
(3, 'CFO', 1),
(4, 'Engineering Manager', 2),
(5, 'Sales Manager', 3),
(6, 'Engineer', 4),
(7, 'Sales Rep', 5);

WITH RECURSIVE employee_hierarchy AS (
    SELECT employee_id, name, manager_id, 1 AS depth
    FROM employees WHERE manager_id IS NULL
    UNION ALL
    SELECT e.employee_id, e.name, e.manager_id, eh.depth + 1
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT * FROM employee_hierarchy;
''').fetchall()
```

**Result**: [(3, 'Electronics', Decimal('1200.00'), 1), (1, 'Electronics', Decimal('500.50'), 2), (4, 'Books', Decimal('75.25'), 1), (2, 'Clothing', Decimal('250.75'), 1)]

**Explanation**: Demonstrates DuckDB's recursive query capability by generating an organizational hierarchy, showing how employees are connected through management levels using a recursive common table expression (CTE).
## Step 3: 2. Custom aggregate function

Failed after 3 attempts: Parser Error: syntax error at or near "AGGREGATE"
## Step 4: 3. Temporal/date window function

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create time series sales data
conn.execute('''
CREATE TABLE daily_sales AS
SELECT * FROM (
    VALUES
    ('2023-01-01', 500.50),
    ('2023-01-02', 250.75),
    ('2023-01-03', 1200.00),
    ('2023-01-04', 750.25)
) t(sale_date, amount)
''')

# Calculate 3-day moving average of sales
result = conn.execute('''
SELECT 
    sale_date, 
    amount,
    AVG(amount) OVER (
        ORDER BY sale_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) as rolling_3day_avg
FROM daily_sales
''').fetchall()

for row in result:
    print(row)
```

**Result**: [('2023-01-01', Decimal('500.50'), 500.5), ('2023-01-02', Decimal('250.75'), 375.625), ('2023-01-03', Decimal('1200.00'), 650.4166666666666), ('2023-01-04', Decimal('750.25'), 733.6666666666666)]

**Explanation**: Demonstrates a temporal window function using a 3-day moving average calculation on sales data, showcasing date-based windowing in DuckDB.
## Step 5: 4. Advanced join technique

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create tables for lateral join example
conn.execute('''
CREATE TABLE departments (dept_id INT, dept_name VARCHAR);
CREATE TABLE employees (emp_id INT, name VARCHAR, salary INT, dept_id INT);

INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES 
(101, 'Alice', 75000, 1),
(102, 'Bob', 65000, 1),
(103, 'Charlie', 80000, 2);
''');

# Perform lateral join to get top 2 earners per department
result = conn.execute('''
SELECT 
    d.dept_name, 
    e.name, 
    e.salary
FROM departments d,
    LATERAL (
        SELECT name, salary
        FROM employees
        WHERE dept_id = d.dept_id
        ORDER BY salary DESC
        LIMIT 2
    ) e
''').fetchall()

for row in result:
    print(row)
```

**Result**: [('Engineering', 'Alice', 75000), ('Engineering', 'Bob', 65000), ('Sales', 'Charlie', 80000)]

**Explanation**: Demonstrates a lateral join, which allows subquery to reference columns from outer query, enabling per-department top salary ranking without complex window functions
## Step 6: I'll craft a small, illustrative implementation focusing on one unique DuckDB capability in the relational API.

Failed after 3 attempts: Catalog Error: Scalar Function with name "st_distance" is not in the catalog, but it exists in the spatial extension.

Please try installing and loading the spatial extension:
INSTALL spatial;
LOAD spatial;


