# Task: I understand you want a precise, focused DuckDB example. I recommend creating a small demonstration of the array_transform function with a numeric list transformation:

```python
import duckdb

con = duckdb.connect()

# Transform numeric array by squaring values
rel = con.query('''
SELECT array_transform([2, 3, 4, 5], x -> x * x) as squared_array
''')

print(rel.execute().fetchall())
```

This concise implementation highlights DuckDB's array transformation capability, showing its flexible functional SQL querying approach by squaring list elements.

## Step 1: I understand you want a precise, focused DuckDB example. I recommend creating a small demonstration of the array_transform function with a numeric list transformation:

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Transform list by squaring each element
result = conn.execute("SELECT array_transform([1, 2, 3, 4, 5], x -> x * x) AS squared_numbers").fetchone()[0]

print(result)  # Output: [1, 4, 9, 16, 25]
```

**Result**: [1, 4, 9, 16, 25]

**Explanation**: Demonstrates DuckDB's array_transform function to apply a lambda-like transformation to each element of a numeric list by squaring the values.
## Step 2: ```python

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Demonstrate advanced window function with multiple calculations
conn.execute('''
    CREATE TABLE sales (
        product TEXT,
        region TEXT,
        amount DECIMAL(10,2)
    );

    INSERT INTO sales VALUES
        ('Widget', 'North', 1000),
        ('Gadget', 'South', 1500),
        ('Widget', 'North', 1200),
        ('Gadget', 'South', 800);

    SELECT 
        product, 
        region, 
        amount,
        SUM(amount) OVER (PARTITION BY product) as total_product_sales,
        RANK() OVER (PARTITION BY region ORDER BY amount DESC) as sales_rank
    FROM sales;
''')

result = conn.fetchall()
for row in result:
    print(row)
```

**Result**: [('Gadget', 'South', Decimal('1500.00'), Decimal('2300.00'), 1), ('Gadget', 'South', Decimal('800.00'), Decimal('2300.00'), 2), ('Widget', 'North', Decimal('1200.00'), Decimal('2200.00'), 1), ('Widget', 'North', Decimal('1000.00'), Decimal('2200.00'), 2)]

**Explanation**: Demonstrates DuckDB's window functions by calculating total product sales and ranking sales within each region, showcasing partition and ranking capabilities in a single query.
## Step 3: import duckdb

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a table with geographic data
conn.execute('''CREATE TABLE cities (
    city TEXT,
    population INT,
    country TEXT,
    latitude DOUBLE,
    longitude DOUBLE
)''')

# Insert sample data
conn.execute('''INSERT INTO cities VALUES
    ('New York', 8500000, 'USA', 40.7128, -74.0060),
    ('London', 9000000, 'UK', 51.5074, -0.1278),
    ('Tokyo', 14000000, 'Japan', 35.6762, 139.6503)''')

# Perform geospatial query using haversine distance
result = conn.execute('''
    SELECT city, 
           ROUND(6371 * 2 * ASIN(SQRT(
               POWER(SIN((RADIANS(40.7128) - RADIANS(latitude)) / 2), 2) +
               COS(RADIANS(40.7128)) * COS(RADIANS(latitude)) *
               POWER(SIN((RADIANS(-74.0060) - RADIANS(longitude)) / 2), 2)
           )), 2) AS distance_km
    FROM cities
    ORDER BY distance_km
''')

print(result.fetchall())
```

**Result**: <duckdb.duckdb.DuckDBPyConnection object at 0x00000147DE9D6CB0>

**Explanation**: Demonstrates a geospatial distance calculation using DuckDB's SQL capabilities, computing the Haversine (great-circle) distance between New York and other cities using trigonometric functions and geospatial math.
## Step 4: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

con = duckdb.connect(':memory:')

# Create and populate a table with Olympic medal data
con.execute('''CREATE TABLE olympic_medals (
    athlete TEXT,
    country TEXT,
    sport TEXT,
    medal_type TEXT
)''')

con.execute('''INSERT INTO olympic_medals VALUES
    ('Simone Biles', 'USA', 'Gymnastics', 'Gold'),
    ('Katie Ledecky', 'USA', 'Swimming', 'Gold'),
    ('Michael Phelps', 'USA', 'Swimming', 'Gold')''')

# Use window function to rank athletes by medal count
result = con.execute('''SELECT 
    athlete, 
    country, 
    sport, 
    COUNT(*) OVER (PARTITION BY country) as country_medals,
    RANK() OVER (ORDER BY medal_type DESC) as medal_rank
FROM olympic_medals''').fetchall()

for row in result:
    print(row)
```

**Result**: [('Simone Biles', 'USA', 'Gymnastics', 3, 1), ('Katie Ledecky', 'USA', 'Swimming', 3, 1), ('Michael Phelps', 'USA', 'Swimming', 3, 1)]

**Explanation**: Demonstrates DuckDB window functions by creating an Olympic medals table and performing ranking and aggregation across partitions
## Step 5: # Transform numeric array by squaring values

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

def square_array(numbers):
    result = conn.execute("SELECT array_transform(?, x -> x * x) AS squared_numbers", [numbers]).fetchone()[0]
    return result

original = [1, 2, 3, 4, 5]
squared = square_array(original)
print(f"Original: {original}")
print(f"Squared: {squared}")
```

**Result**: [('Simone Biles', 'USA', 'Gymnastics', 3, 1), ('Katie Ledecky', 'USA', 'Swimming', 3, 1), ('Michael Phelps', 'USA', 'Swimming', 3, 1)]

**Explanation**: Demonstrates DuckDB's array_transform function to square numeric array values, using a parameterized query for flexibility and showing how to convert lists through SQL functions
## Step 6: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

con = duckdb.connect(':memory:')

# Create a nested subquery with lateral join and window functions
con.execute('''
CREATE TABLE employees (
    id INT,
    name TEXT,
    department TEXT,
    salary DECIMAL(10,2)
);

INSERT INTO employees VALUES
    (1, 'Alice', 'Sales', 50000),
    (2, 'Bob', 'Marketing', 60000),
    (3, 'Charlie', 'Sales', 55000),
    (4, 'David', 'Marketing', 65000);

SELECT 
    department, 
    name, 
    salary,
    FIRST_VALUE(name) OVER (PARTITION BY department ORDER BY salary DESC) as top_earner,
    DENSE_RANK() OVER (ORDER BY salary DESC) as salary_rank
FROM employees
''')

result = con.fetchall()
for row in result:
    print(row)
```

**Result**: [('Marketing', 'David', Decimal('65000.00'), 'David', 1), ('Marketing', 'Bob', Decimal('60000.00'), 'David', 2), ('Sales', 'Charlie', Decimal('55000.00'), 'Charlie', 3), ('Sales', 'Alice', Decimal('50000.00'), 'Charlie', 4)]

**Explanation**: Demonstrates advanced window functions with lateral join, showing multi-dimensional analysis of employee salaries across departments, including identifying top earners and ranking employees globally
## Step 7: SELECT array_transform([2, 3, 4, 5], x -> x * x) as squared_array

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute("SELECT array_transform([2, 3, 4, 5], x -> x * x) as squared_array").fetchone()[0]
print(result)
```

**Result**: [4, 9, 16, 25]

**Explanation**: Demonstrates array_transform with lambda function to square each array element using DuckDB's SQL syntax
## Step 8: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Recursive common table expression (CTE) to generate fibonacci sequence
result = conn.execute('''
WITH RECURSIVE fibonacci(n, a, b) AS (
    SELECT 1, 0, 1
    UNION ALL
    SELECT n+1, b, a+b FROM fibonacci WHERE n < 10
)
SELECT n, b AS fibonacci_number FROM fibonacci
''').fetchall()

for row in result:
    print(row)
```

**Result**: [(1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13), (8, 21), (9, 34), (10, 55)]

**Explanation**: Demonstrates DuckDB's support for recursive common table expressions by generating the first 10 numbers in the Fibonacci sequence using a recursive CTE. Shows how complex mathematical sequences can be computed directly in SQL.
## Step 9: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
conn.execute('CREATE TABLE numbers (val INTEGER)')
conn.execute('INSERT INTO numbers VALUES (1), (2), (3), (4), (5)')

rel = conn.table('numbers').filter('val > 2').project('val * 2 AS doubled_val')
print(rel.execute().fetchall())
```

**Result**: [(1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13), (8, 21), (9, 34), (10, 55)]

**Explanation**: Creates an in-memory table with numbers, then uses the relational API to filter values greater than 2 and project those values multiplied by 2, demonstrating DuckDB's fluent query interface.
## Step 10: ```

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create and analyze time series data with lead/lag functions
conn.execute('''
CREATE TABLE stock_prices (
    date DATE,
    stock TEXT,
    price DECIMAL(10,2)
);

INSERT INTO stock_prices VALUES
    ('2023-01-01', 'AAPL', 150.50),
    ('2023-01-02', 'AAPL', 152.25),
    ('2023-01-03', 'AAPL', 149.75),
    ('2023-01-04', 'AAPL', 153.00);

SELECT 
    date, 
    stock, 
    price,
    LAG(price) OVER (PARTITION BY stock ORDER BY date) as previous_price,
    LEAD(price) OVER (PARTITION BY stock ORDER BY date) as next_price,
    price - LAG(price) OVER (PARTITION BY stock ORDER BY date) as price_change
FROM stock_prices
''')

result = conn.fetchall()
for row in result:
    print(row)
```

**Result**: [(datetime.date(2023, 1, 1), 'AAPL', Decimal('150.50'), None, Decimal('152.25'), None), (datetime.date(2023, 1, 2), 'AAPL', Decimal('152.25'), Decimal('150.50'), Decimal('149.75'), Decimal('1.75')), (datetime.date(2023, 1, 3), 'AAPL', Decimal('149.75'), Decimal('152.25'), Decimal('153.00'), Decimal('-2.50')), (datetime.date(2023, 1, 4), 'AAPL', Decimal('153.00'), Decimal('149.75'), None, Decimal('3.25'))]

**Explanation**: Demonstrates DuckDB's window functions for time series analysis, using LAG and LEAD to compare stock prices across consecutive dates, calculating price changes and retrieving historical context.
## Step 11: This concise implementation highlights DuckDB's array transformation capability, showing its flexible functional SQL querying approach by squaring list elements.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute("SELECT array_transform([1, 2, 3, 4, 5], x -> x * x) AS squared_array").fetchone()[0]
print(result)
```

**Result**: [1, 4, 9, 16, 25]

**Explanation**: Demonstrates DuckDB's array_transform function to square each element in a list using a lambda-like SQL function, showcasing inline functional array manipulation.
