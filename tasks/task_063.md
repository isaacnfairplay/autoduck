# Task: I understand you want a small, focused DuckDB example. Here's a concise demonstration of the array_transform function for list manipulation:

```python
import duckdb

con = duckdb.connect()

# Transform numeric array by adding 10 to each element
rel = con.query('''
SELECT array_transform([1, 2, 3, 4], x -> x + 10) as incremented_array
''')

print(rel.execute().fetchall())
```

This targeted implementation showcases DuckDB's array_transform capability by incrementing list elements, highlighting its flexible functional SQL querying approach.

## Step 1: I understand you want a small, focused DuckDB example. Here's a concise demonstration of the array_transform function for list manipulation:

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Transform list elements using array_transform
query = '''
SELECT array_transform([1, 2, 3, 4], x -> x * 2) AS doubled_list;
'''

result = conn.execute(query).fetchone()[0]
print(result)  # Output: [2, 4, 6, 8]
```

**Result**: [2, 4, 6, 8]

**Explanation**: Demonstrates array_transform for in-place list element manipulation by multiplying each element by 2 using a lambda function.
## Step 2: ```python

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a temporary table and apply a window function
conn.execute("""
CREATE TABLE sales (
    product TEXT,
    region TEXT,
    amount DECIMAL
);

INSERT INTO sales VALUES
    ('Widget', 'North', 1000),
    ('Gadget', 'North', 1500),
    ('Widget', 'South', 800),
    ('Gadget', 'South', 1200);

SELECT 
    product, 
    region, 
    amount,
    RANK() OVER (PARTITION BY region ORDER BY amount DESC) as sales_rank
FROM sales;
""")

# Fetch and print results
results = conn.fetchall()
for row in results:
    print(row)
```

**Result**: [2, 4, 6, 8]

**Explanation**: Demonstrates a window function (RANK) used to rank sales amounts within each region, showing how DuckDB supports advanced analytical queries with minimal setup.
## Step 3: import duckdb

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Recursive common table expression to generate a Fibonacci sequence
query = '''
WITH RECURSIVE fibonacci(n, a, b) AS (
    SELECT 1, 0, 1
    UNION ALL
    SELECT n + 1, b, a + b
    FROM fibonacci
    WHERE n < 10
)
SELECT n, a AS fibonacci_number
FROM fibonacci;
'''

results = conn.execute(query).fetchall()
for result in results:
    print(f'Position {result[0]}: {result[1]}')
```

**Result**: (10, 34)

**Explanation**: Demonstrates a recursive CTE in DuckDB to generate the first 10 Fibonacci numbers by using a recursive query that tracks sequence position and calculates values iteratively.
## Step 4: con = duckdb.connect()

Failed after 3 attempts: Catalog Error: Scalar Function with name "st_point" is not in the catalog, but it exists in the spatial extension.

Please try installing and loading the spatial extension:
INSTALL spatial;
LOAD spatial;


## Step 5: # Transform numeric array by adding 10 to each element

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

query = '''
SELECT array_transform([1, 2, 3, 4, 5], x -> x + 10) AS transformed_array;
'''

result = conn.execute(query).fetchone()[0]
print(result)  # Should output: [11, 12, 13, 14, 15]
```

**Result**: [11, 12, 13, 14, 15]

**Explanation**: Demonstrates array_transform() to add 10 to each numeric array element using an anonymous lambda function within a SQL query
## Step 6: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sample sensor temperature data
conn.execute('''
CREATE TABLE sensor_readings (
    sensor_id INTEGER,
    temperature DECIMAL(5,2),
    timestamp TIMESTAMP
);

INSERT INTO sensor_readings VALUES
    (1, 22.5, '2023-06-15 10:00:00'),
    (1, 23.1, '2023-06-15 10:15:00'),
    (2, 21.8, '2023-06-15 10:00:00'),
    (2, 22.3, '2023-06-15 10:15:00');
'''
)

# Calculate moving average of temperatures per sensor
query = '''
SELECT 
    sensor_id, 
    timestamp,
    temperature,
    AVG(temperature) OVER (
        PARTITION BY sensor_id 
        ORDER BY timestamp 
        ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
    ) as moving_avg
FROM sensor_readings
ORDER BY sensor_id, timestamp;
'''

results = conn.execute(query).fetchall()
for result in results:
    print(result)
```

**Result**: (2, datetime.datetime(2023, 6, 15, 10, 15), Decimal('22.30'), 22.05)

**Explanation**: Demonstrates a window function calculating a moving average of temperature readings per sensor, showing time-based windowing and partitioning capabilities in DuckDB
## Step 7: SELECT array_transform([1, 2, 3, 4], x -> x + 10) as incremented_array

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
query = '''
SELECT array_transform([1, 2, 3, 4], x -> x + 10) as incremented_array
'''

result = conn.execute(query).fetchone()[0]
print(result)
```

**Result**: [11, 12, 13, 14]

**Explanation**: Demonstrates DuckDB's array_transform function to increment each array element by 10, creating a new array with transformed values
## Step 8: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# JSON parsing and transformation example
query = '''
SELECT
    json_extract(json_str, '$.name') as person_name,
    json_extract_string(json_str, '$.age') as person_age
FROM (
    SELECT '{
        "name": "Alice",
        "age": 30,
        "city": "New York"
    }' as json_str
);
'''

result = conn.execute(query).fetchall()
for row in result:
    print(f'Name: {row[0]}, Age: {row[1]}')
```

**Result**: [('"Alice"', '30')]

**Explanation**: Demonstrates DuckDB's JSON extraction capabilities, showing how to parse and extract specific fields from a JSON string using built-in JSON functions like json_extract and json_extract_string.
## Step 9: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

rel = conn.sql('SELECT * FROM (VALUES (1, 2), (3, 4), (5, 6)) AS t(a, b)')
print(rel.execute().fetchall())
```

**Result**: [('"Alice"', '30')]

**Explanation**: Creates an in-memory DuckDB connection and constructs a relation from a values list, then executes and prints all rows. Demonstrates basic relation creation and execution.
## Step 10: ```

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Demonstrate multi-level nested aggregation
conn.execute('''CREATE TABLE product_sales (
    category TEXT,
    subcategory TEXT,
    sales DECIMAL
);

INSERT INTO product_sales VALUES
    ('Electronics', 'Laptops', 5000),
    ('Electronics', 'Smartphones', 7500),
    ('Clothing', 'Mens', 3000),
    ('Clothing', 'Womens', 4500);
''')

query = '''
SELECT 
    category, 
    SUM(sales) as total_category_sales,
    AVG(sales) as avg_subcategory_sales
FROM product_sales
GROUP BY category
ORDER BY total_category_sales DESC;
'''

results = conn.execute(query).fetchall()
for result in results:
    print(f'Category: {result[0]}, Total Sales: {result[1]}, Avg Subcategory Sales: {result[2]}')
```

**Result**: ('Clothing', Decimal('7500.000'), 3750.0)

**Explanation**: This example demonstrates multi-level aggregation in DuckDB by creating a product sales table and performing summary calculations across categories, showing total and average sales using GROUP BY and aggregate functions.
## Step 11: This targeted implementation showcases DuckDB's array_transform capability by incrementing list elements, highlighting its flexible functional SQL querying approach.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

query = '''
SELECT array_transform([10, 20, 30, 40], x -> x + 5) as incremented_array
'''

result = conn.execute(query).fetchone()[0]
print(result)  # Output: [15, 25, 35, 45]
```

**Result**: [15, 25, 35, 45]

**Explanation**: Demonstrates DuckDB's array_transform function by incrementing each element of a list by 5, showcasing the functional SQL transformation capability through lambda-like syntax.
