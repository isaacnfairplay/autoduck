# Task: I'll create a concise example demonstrating DuckDB's array_transform function for list manipulation:

```python
import duckdb

con = duckdb.connect()

# Transform numeric array by adding 10 to each element
rel = con.query('''
SELECT array_transform([1, 2, 3, 4], x -> x + 10) as incremented_array
''')

print(rel.execute().fetchall())
```

This targeted implementation showcases DuckDB's array_transform capability by incrementing list elements, highlighting its flexible functional SQL querying approach.

## Step 1: I'll create a concise example demonstrating DuckDB's array_transform function for list manipulation:

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a table with arrays and transform them
conn.execute('''
    CREATE TABLE numbers (id INTEGER, values INTEGER[]);
    INSERT INTO numbers VALUES
        (1, [1, 2, 3]),
        (2, [4, 5, 6]),
        (3, [7, 8, 9]);
''')

# Use array_transform to square each element
result = conn.execute('''
    SELECT 
        id, 
        array_transform(values, x -> x * x) AS squared_values
    FROM numbers
''').fetchall()

for row in result:
    print(f"ID: {row[0]}, Squared Values: {row[1]}")
```

**Result**: [(1, [1, 4, 9]), (2, [16, 25, 36]), (3, [49, 64, 81])]

**Explanation**: Demonstrates DuckDB's array_transform function by squaring elements in integer arrays, showing functional list manipulation within SQL
## Step 2: ```python

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a table with temporal data and perform windowing
conn.execute('''CREATE TABLE sales (
    product STRING,
    sale_date DATE,
    amount DECIMAL(10,2)
);''')

conn.execute('''INSERT INTO sales VALUES
    ('Apple', '2023-01-15', 100.50),
    ('Banana', '2023-01-16', 75.25),
    ('Apple', '2023-01-17', 125.75),
    ('Banana', '2023-01-18', 90.00);
''')

# Calculate cumulative sales and running averages per product
result = conn.execute('''
    SELECT 
        product, 
        sale_date, 
        amount,
        SUM(amount) OVER (PARTITION BY product ORDER BY sale_date) as cumulative_sales,
        AVG(amount) OVER (PARTITION BY product ORDER BY sale_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as rolling_avg
    FROM sales
    ORDER BY product, sale_date
''').fetchall()

for row in result:
    print(f"Product: {row[0]}, Date: {row[1]}, Amount: ${row[2]}, Cumulative Sales: ${row[3]}, Rolling Avg: ${row[4]:.2f}")
```

**Result**: [('Apple', datetime.date(2023, 1, 15), Decimal('100.50'), Decimal('100.50'), 100.5), ('Apple', datetime.date(2023, 1, 17), Decimal('125.75'), Decimal('226.25'), 113.125), ('Banana', datetime.date(2023, 1, 16), Decimal('75.25'), Decimal('75.25'), 75.25), ('Banana', datetime.date(2023, 1, 18), Decimal('90.00'), Decimal('165.25'), 82.625)]

**Explanation**: Demonstrates DuckDB's window functions by calculating cumulative sales and rolling averages for products over time, showcasing temporal data analysis with partitioning and framing
## Step 3: import duckdb

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create and populate graph-like relationship table
conn.execute('''
    CREATE TABLE social_network (
        person_id INTEGER,
        friend_id INTEGER
    );
    INSERT INTO social_network VALUES
        (1, 2), (1, 3), (2, 4),
        (3, 4), (4, 5), (5, 1);

    -- Recursive query to find network connections
    WITH RECURSIVE network_paths(start_id, end_id, path, depth) AS (
        SELECT person_id, friend_id, 
               CAST(person_id || '->' || friend_id AS VARCHAR) AS path, 
               1 AS depth
        FROM social_network
        UNION ALL
        SELECT np.start_id, sn.friend_id, 
               np.path || '->' || sn.friend_id, 
               np.depth + 1
        FROM network_paths np
        JOIN social_network sn ON np.end_id = sn.person_id
        WHERE np.depth < 3
    )
    SELECT DISTINCT start_id, end_id, path, depth
    FROM network_paths
    ORDER BY depth;
''').fetchall()
```

**Result**: [('Apple', datetime.date(2023, 1, 15), Decimal('100.50'), Decimal('100.50'), 100.5), ('Apple', datetime.date(2023, 1, 17), Decimal('125.75'), Decimal('226.25'), 113.125), ('Banana', datetime.date(2023, 1, 16), Decimal('75.25'), Decimal('75.25'), 75.25), ('Banana', datetime.date(2023, 1, 18), Decimal('90.00'), Decimal('165.25'), 82.625)]

**Explanation**: Demonstrates DuckDB's recursive query capabilities by modeling a social network graph, finding multi-hop connections with traversal depth tracking
## Step 4: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

con = duckdb.connect(':memory:')

# Create a complex multi-dimensional array transformation example
con.execute('''
CREATE TABLE nested_data (
    id INTEGER,
    nested_array INTEGER[][]
);

INSERT INTO nested_data VALUES
    (1, [[1, 2], [3, 4]]),
    (2, [[5, 6], [7, 8]]);

SELECT 
    id, 
    array_transform(nested_array, x -> array_transform(x, y -> y * 2)) AS doubled_array
FROM nested_data;
'''
)

result = con.execute('''
SELECT 
    id, 
    array_transform(nested_array, x -> array_transform(x, y -> y * 2)) AS doubled_array
FROM nested_data;
''').fetchall()

for row in result:
    print(f"ID: {row[0]}, Transformed Array: {row[1]})")
```

**Result**: [(1, [[2, 4], [6, 8]]), (2, [[10, 12], [14, 16]])]

**Explanation**: Demonstrates nested array transformation using array_transform, creating a two-dimensional array manipulation example that applies a multiplication operation across nested arrays
## Step 5: # Transform numeric array by adding 10 to each element

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('''
CREATE TABLE numeric_arrays (id INTEGER, values INTEGER[]);
INSERT INTO numeric_arrays VALUES
    (1, [1, 2, 3]),
    (2, [4, 5, 6]);
''')

result = conn.execute('''
SELECT
    id,
    array_transform(values, x -> x + 10) AS transformed_values
FROM numeric_arrays
''').fetchall()

for row in result:
    print(f"ID: {row[0]}, Transformed: {row[1]})")
```

**Result**: [(1, [11, 12, 13]), (2, [14, 15, 16])]

**Explanation**: Demonstrates DuckDB's array_transform function to add 10 to each element of an integer array, showing dynamic array element modification
## Step 6: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create table of sensor readings with time series data
conn.execute('''CREATE TABLE sensor_readings (
    device_id INTEGER,
    timestamp TIMESTAMP,
    temperature FLOAT,
    humidity FLOAT
)''')

conn.execute('''INSERT INTO sensor_readings VALUES
    (1, '2023-06-01 10:00:00', 22.5, 45.3),
    (1, '2023-06-01 10:15:00', 23.1, 46.2),
    (2, '2023-06-01 10:00:00', 19.8, 55.7),
    (2, '2023-06-01 10:15:00', 20.2, 54.9)''')

# Calculate rolling temperature average per device
result = conn.execute('''
SELECT
    device_id,
    timestamp,
    temperature,
    AVG(temperature) OVER (
        PARTITION BY device_id
        ORDER BY timestamp
        ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
    ) AS rolling_temp_avg
FROM sensor_readings
ORDER BY device_id, timestamp
''').fetchall()

for row in result:
    print(f"Device: {row[0]}, Timestamp: {row[1]}, Temperature: {row[2]}, Rolling Avg: {row[3]}")
```

**Result**: [(1, datetime.datetime(2023, 6, 1, 10, 0), 22.5, 22.5), (1, datetime.datetime(2023, 6, 1, 10, 15), 23.100000381469727, 22.800000190734863), (2, datetime.datetime(2023, 6, 1, 10, 0), 19.799999237060547, 19.799999237060547), (2, datetime.datetime(2023, 6, 1, 10, 15), 20.200000762939453, 20.0)]

**Explanation**: Demonstrates time series analysis using DuckDB's window functions, calculating a rolling temperature average for multiple sensor devices with partitioning and ordered windowing.
## Step 7: SELECT array_transform([1, 2, 3, 4], x -> x + 10) as incremented_array

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute("SELECT array_transform([1, 2, 3, 4], x -> x + 10) as incremented_array").fetchone()[0]
print(result)
```

**Result**: [11, 12, 13, 14]

**Explanation**: Demonstrates DuckDB's array_transform function to incrementally add 10 to each array element, leveraging inline lambda transformation
## Step 8: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create table with product inventory
conn.execute('''CREATE TABLE inventory (
    product_id INTEGER,
    product_name STRING,
    quantity INTEGER,
    price DECIMAL(10,2)
)''')

conn.execute('''INSERT INTO inventory VALUES
    (1, 'Laptop', 50, 999.99),
    (2, 'Smartphone', 100, 599.50),
    (3, 'Tablet', 75, 349.99)''')

# Calculate total inventory value using window function
result = conn.execute('''SELECT 
    product_name, 
    quantity, 
    price, 
    quantity * price AS total_value,
    SUM(quantity * price) OVER () AS grand_total_inventory
FROM inventory''').fetchall()

for row in result:
    print(f"Product: {row[0]}, Quantity: {row[1]}, Price: ${row[2]}, Total Value: ${row[3]}, Grand Total Inventory: ${row[4]:.2f}")
```

**Result**: [('Laptop', 50, Decimal('999.99'), Decimal('49999.50'), Decimal('136198.75')), ('Smartphone', 100, Decimal('599.50'), Decimal('59950.00'), Decimal('136198.75')), ('Tablet', 75, Decimal('349.99'), Decimal('26249.25'), Decimal('136198.75'))]

**Explanation**: Demonstrates DuckDB's window function capabilities by calculating individual product total values and overall inventory value in a single query.
## Step 9: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
conn.execute('CREATE TABLE numbers (n INTEGER)')
conn.execute('INSERT INTO numbers VALUES (1), (2), (3), (4), (5)')

rel = conn.table('numbers').filter('n > 2').project('n * 2 as doubled')
print(rel.execute().fetchall())
```

**Result**: [('Laptop', 50, Decimal('999.99'), Decimal('49999.50'), Decimal('136198.75')), ('Smartphone', 100, Decimal('599.50'), Decimal('59950.00'), Decimal('136198.75')), ('Tablet', 75, Decimal('349.99'), Decimal('26249.25'), Decimal('136198.75'))]

**Explanation**: Creates an in-memory table with numbers, filters rows greater than 2, projects and doubles those values, then executes and prints the result set
## Step 10: ```

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a table with geographic coordinates
conn.execute('''CREATE TABLE locations (
    city STRING,
    latitude FLOAT,
    longitude FLOAT
)''')

conn.execute('''INSERT INTO locations VALUES
    ('New York', 40.7128, -74.0060),
    ('Los Angeles', 34.0522, -118.2437),
    ('Chicago', 41.8781, -87.6298)''')

# Calculate distance between locations using Haversine formula
result = conn.execute('''SELECT
    city,
    6371 * 2 * ASIN(SQRT(
        POWER(SIN((latitude - 40.7128) * PI() / 360), 2) +
        COS(latitude * PI() / 180) * COS(40.7128 * PI() / 180) *
        POWER(SIN((longitude - (-74.0060)) * PI() / 360), 2)
    )) AS distance_km
FROM locations
ORDER BY distance_km''').fetchall()

for row in result:
    print(f"City: {row[0]}, Distance from New York: {row[1]:.2f} km")
```

**Result**: [('New York', 0.0), ('Chicago', 1144.2914716113733), ('Los Angeles', 3935.7463386530785)]

**Explanation**: Demonstrates geospatial calculation using DuckDB's mathematical functions to compute distances between cities using the Haversine formula, showcasing advanced trigonometric and spatial query capabilities
## Step 11: This targeted implementation showcases DuckDB's array_transform capability by incrementing list elements, highlighting its flexible functional SQL querying approach.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute("SELECT array_transform([10, 20, 30], x -> x + 5) as incremented_array").fetchone()[0]
print(result)
```

**Result**: [15, 25, 35]

**Explanation**: Demonstrates array_transform by adding 5 to each element of a numeric list, showcasing DuckDB's functional array manipulation capabilities in a single, compact query.
