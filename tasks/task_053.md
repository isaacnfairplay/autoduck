# Task: ```python
import duckdb

con = duckdb.connect()

# Transform numeric array by squaring values
rel = con.query('''
SELECT array_transform([2, 3, 4, 5], x -> x * x) as squared_array
''')

print(rel.execute().fetchall())
```

This concise implementation demonstrates DuckDB's array_transform function by squaring list elements, highlighting its flexible functional SQL querying approach.

## Step 1: ```python

**Generated by**: Anthropic

```python
import duckdb

# Create an in-memory database connection
conn = duckdb.connect(':memory:')

# Create a sample sales table
conn.execute('''
    CREATE TABLE sales (
        product_id INT,
        sale_date DATE,
        quantity INT,
        price DECIMAL(10,2)
    );
''')

# Insert sample data
conn.executemany('INSERT INTO sales VALUES (?, ?, ?, ?)', [
    (1, '2023-01-15', 5, 10.50),
    (2, '2023-02-20', 3, 25.75),
    (1, '2023-03-10', 7, 10.50)
])

# Perform a window function analysis
result = conn.execute('''
    SELECT 
        product_id, 
        sale_date, 
        quantity,
        SUM(quantity) OVER (PARTITION BY product_id ORDER BY sale_date) as cumulative_quantity,
        AVG(price) OVER (PARTITION BY product_id) as avg_product_price
    FROM sales
''').fetchall()

print(result)
```

**Result**: [(1, datetime.date(2023, 1, 15), 5, 5, 10.5), (1, datetime.date(2023, 3, 10), 7, 12, 10.5), (2, datetime.date(2023, 2, 20), 3, 3, 25.75)]

**Explanation**: Demonstrates creating an in-memory database, inserting data, and using window functions to calculate cumulative sales and average price per product
## Step 2: import duckdb

**Generated by**: Anthropic

```python
import duckdb

# Create in-memory database
conn = duckdb.connect(':memory:')

# Create and populate customer order table
conn.execute('CREATE TABLE orders (customer_id INT, order_date DATE, total_amount DECIMAL(10,2))')
conn.executemany('INSERT INTO orders VALUES (?, ?, ?)', [
    (1, '2023-05-01', 150.50),
    (2, '2023-05-02', 275.25),
    (1, '2023-05-03', 89.99)
])

# Analyze orders using window functions
result = conn.execute('''
    SELECT 
        customer_id, 
        order_date, 
        total_amount,
        SUM(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) as cumulative_spend,
        RANK() OVER (ORDER BY total_amount DESC) as order_rank
    FROM orders
''').fetchall()

print(result)
```

**Result**: [(2, datetime.date(2023, 5, 2), Decimal('275.25'), Decimal('275.25'), 1), (1, datetime.date(2023, 5, 1), Decimal('150.50'), Decimal('150.50'), 2), (1, datetime.date(2023, 5, 3), Decimal('89.99'), Decimal('240.49'), 3)]

**Explanation**: Demonstrates DuckDB window functions to track customer spending and rank orders by total amount, showcasing advanced analytical capabilities with in-memory data processing
## Step 3: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create geographical sales data
conn.execute('CREATE TABLE regional_sales (region VARCHAR, product VARCHAR, sales_amount DECIMAL(10,2))')
conn.executemany('INSERT INTO regional_sales VALUES (?, ?, ?)', [
    ('North', 'Laptop', 5000.50),
    ('South', 'Tablet', 3200.75),
    ('East', 'Phone', 4500.25),
    ('West', 'Laptop', 6200.00)
])

# Use window function and ranking to analyze regional sales performance
result = conn.execute('''
    SELECT 
        region, 
        product, 
        sales_amount,
        RANK() OVER (PARTITION BY region ORDER BY sales_amount DESC) as regional_rank,
        DENSE_RANK() OVER (ORDER BY sales_amount DESC) as overall_rank
    FROM regional_sales
''').fetchall()

print(result)
```

**Result**: [('West', 'Laptop', Decimal('6200.00'), 1, 1), ('North', 'Laptop', Decimal('5000.50'), 1, 2), ('East', 'Phone', Decimal('4500.25'), 1, 3), ('South', 'Tablet', Decimal('3200.75'), 1, 4)]

**Explanation**: Demonstrates DuckDB's window function capabilities by ranking sales performance both within regions and across all regions, showcasing advanced analytical querying.
## Step 4: # Transform numeric array by squaring values

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create array column and transform values
result = conn.execute('''
    SELECT [1, 2, 3, 4, 5] AS original_array,
           array_transform([1, 2, 3, 4, 5], x -> x * x) AS squared_array
''').fetchall()

print(result)
```

**Result**: [([1, 2, 3, 4, 5], [1, 4, 9, 16, 25])]

**Explanation**: Demonstrates DuckDB's array_transform() function to square numeric array elements using lambda function, showing functional array manipulation capabilities
## Step 5: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

# Create in-memory database
conn = duckdb.connect(':memory:')

# Create employee hierarchy table
conn.execute('''
    CREATE TABLE employees (
        id INT PRIMARY KEY,
        name VARCHAR,
        manager_id INT
    );
''')

# Insert hierarchical data
conn.executemany('INSERT INTO employees VALUES (?, ?, ?)', [
    (1, 'Alice', None),
    (2, 'Bob', 1),
    (3, 'Charlie', 1),
    (4, 'David', 2)
])

# Recursive CTE to show employee hierarchy
result = conn.execute('''
    WITH RECURSIVE employee_hierarchy AS (
        SELECT id, name, manager_id, 0 as depth
        FROM employees
        WHERE manager_id IS NULL
        UNION ALL
        SELECT e.id, e.name, e.manager_id, eh.depth + 1
        FROM employees e
        JOIN employee_hierarchy eh ON e.manager_id = eh.id
    )
    SELECT * FROM employee_hierarchy
    ORDER BY depth, id
''').fetchall()

print(result)
```

**Result**: [(1, 'Alice', None, 0), (2, 'Bob', 1, 1), (3, 'Charlie', 1, 1), (4, 'David', 2, 2)]

**Explanation**: Demonstrates a recursive Common Table Expression (CTE) to traverse an employee hierarchy, showing nested management relationships and organizational depth.
## Step 6: SELECT array_transform([2, 3, 4, 5], x -> x * x) as squared_array

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute("SELECT array_transform([2, 3, 4, 5], x -> x * x) as squared_array").fetchall()
print(result)
```

**Result**: [([4, 9, 16, 25],)]

**Explanation**: Demonstrates DuckDB's array_transform function to square each element in an array using a lambda expression
## Step 7: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sensor temperature readings with time series analysis
conn.execute('''
    CREATE TABLE sensor_readings (
        sensor_id INT,
        reading_time TIMESTAMP,
        temperature FLOAT
    );
''')

conn.executemany('INSERT INTO sensor_readings VALUES (?, ?, ?)', [
    (1, '2023-06-01 10:00:00', 22.5),
    (1, '2023-06-01 11:00:00', 23.1),
    (1, '2023-06-01 12:00:00', 23.7),
    (2, '2023-06-01 10:00:00', 21.3)
])

# Analyze temperature trend using window functions
result = conn.execute('''
    SELECT 
        sensor_id, 
        reading_time,
        temperature,
        AVG(temperature) OVER (PARTITION BY sensor_id ORDER BY reading_time ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as moving_avg
    FROM sensor_readings
''').fetchall()

print(result)
```

**Result**: [(1, datetime.datetime(2023, 6, 1, 10, 0), 22.5, 22.5), (1, datetime.datetime(2023, 6, 1, 11, 0), 23.100000381469727, 22.800000190734863), (1, datetime.datetime(2023, 6, 1, 12, 0), 23.700000762939453, 23.40000057220459), (2, datetime.datetime(2023, 6, 1, 10, 0), 21.299999237060547, 21.299999237060547)]

**Explanation**: Demonstrates time series analysis with DuckDB by creating sensor temperature readings and calculating a moving average using window functions over partitioned sensor data
## Step 8: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
conn.execute('CREATE TABLE numbers (value INT)')
conn.executemany('INSERT INTO numbers VALUES (?)', [(x,) for x in range(1, 6)])

rel = conn.sql('SELECT value, value * value as squared FROM numbers')
print(rel.execute().fetchall())
```

**Result**: [(1, datetime.datetime(2023, 6, 1, 10, 0), 22.5, 22.5), (1, datetime.datetime(2023, 6, 1, 11, 0), 23.100000381469727, 22.800000190734863), (1, datetime.datetime(2023, 6, 1, 12, 0), 23.700000762939453, 23.40000057220459), (2, datetime.datetime(2023, 6, 1, 10, 0), 21.299999237060547, 21.299999237060547)]

**Explanation**: Creates an in-memory table with numbers 1-5, then uses DuckDB's relational API to select values and compute their squares, demonstrating basic projection and computation.
## Step 9: ```

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.execute('CREATE TABLE products (id INT, name VARCHAR, category VARCHAR, price DECIMAL(10,2))')

conn.executemany('INSERT INTO products VALUES (?, ?, ?, ?)', [
    (1, 'Laptop', 'Electronics', 999.99),
    (2, 'Smartphone', 'Electronics', 599.50),
    (3, 'Headphones', 'Accessories', 199.99)
])

# Complex aggregation and filtering across categories
result = conn.execute('''
    SELECT 
        category, 
        COUNT(*) as product_count,
        AVG(price) as avg_price,
        MAX(price) as max_price
    FROM products
    WHERE price > 500
    GROUP BY category
    HAVING COUNT(*) > 0
    ORDER BY avg_price DESC
''').fetchall()

print(result)
```

**Result**: [('Electronics', 2, 799.745, Decimal('999.99'))]

**Explanation**: Demonstrates DuckDB's SQL capabilities with table creation, data insertion, aggregation, filtering, and complex querying across product categories
## Step 10: This concise implementation demonstrates DuckDB's array_transform function by squaring list elements, highlighting its flexible functional SQL querying approach.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute("SELECT array_transform([1, 2, 3, 4, 5], x -> x * x) as squared_array").fetchall()
print(result)
```

**Result**: [([1, 4, 9, 16, 25],)]

**Explanation**: Demonstrates DuckDB's array_transform function by applying a lambda function to square each element in a list, showcasing the database's functional array manipulation capabilities
