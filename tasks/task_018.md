# Task: I'll create a small, focused example demonstrating a unique DuckDB relational API feature for window functions showing cumulative calculations:```python
import duckdb

con = duckdb.connect()

# Create sales data
con.execute('''
CREATE TABLE sales AS 
SELECT * FROM (VALUES 
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Electronics', 'Tablet', 500)
) AS t(category, product, amount)
''')

# Calculate running total per category
rel = con.query('''
SELECT 
    category, 
    product, 
    amount,
    SUM(amount) OVER (PARTITION BY category ORDER BY amount) as running_total
FROM sales
''')

print(rel.execute().fetchall())```

## Step 1: I'll create a small, focused example demonstrating a unique DuckDB relational API feature for window functions showing cumulative calculations:```python

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a sample sales dataset
conn.execute('''
    CREATE TABLE sales (product TEXT, sale_date DATE, amount DECIMAL(10,2))
''')

conn.executemany('INSERT INTO sales VALUES (?, ?, ?)', [
    ('Laptop', '2023-01-15', 1200.50),
    ('Phone', '2023-01-16', 800.25),
    ('Laptop', '2023-01-17', 1500.75),
    ('Tablet', '2023-01-18', 600.00),
    ('Phone', '2023-01-19', 950.30)
])

# Use window function to calculate rolling cumulative sales per product
result = conn.execute('''
    SELECT 
        product, 
        sale_date, 
        amount,
        SUM(amount) OVER (PARTITION BY product ORDER BY sale_date) as cumulative_sales
    FROM sales
    ORDER BY product, sale_date
''').fetchall()

for row in result:
    print(f"Product: {row[0]}, Date: {row[1]}, Sale: ${row[2]}, Cumulative Sales: ${row[3]}")
```

**Result**: [('Laptop', datetime.date(2023, 1, 15), Decimal('1200.50'), Decimal('1200.50')), ('Laptop', datetime.date(2023, 1, 17), Decimal('1500.75'), Decimal('2701.25')), ('Phone', datetime.date(2023, 1, 16), Decimal('800.25'), Decimal('800.25')), ('Phone', datetime.date(2023, 1, 19), Decimal('950.30'), Decimal('1750.55')), ('Tablet', datetime.date(2023, 1, 18), Decimal('600.00'), Decimal('600.00'))]

**Explanation**: Demonstrates a window function with cumulative calculation, partitioned by product and ordered by sale date. Shows how to track running totals within specific groupings using DuckDB's advanced windowing capabilities.
## Step 2: import duckdb

**Generated by**: Anthropic

```python
import duckdb

# Connect to an in-memory database
conn = duckdb.connect(':memory:')

# Create and populate a sample temperature dataset
conn.execute('CREATE TABLE weather (city TEXT, temp_f DECIMAL(5,2), recorded_at TIMESTAMP)')
conn.executemany('INSERT INTO weather VALUES (?, ?, ?)', [
    ('New York', 72.5, '2023-07-15 10:00:00'),
    ('Chicago', 68.3, '2023-07-15 11:00:00'),
    ('Los Angeles', 85.2, '2023-07-15 09:00:00'),
    ('Houston', 90.1, '2023-07-15 12:00:00')
])

# Use window function to rank cities by temperature
result = conn.execute('''
    SELECT 
        city, 
        temp_f, 
        RANK() OVER (ORDER BY temp_f DESC) as temp_rank
    FROM weather
''').fetchall()

for row in result:
    print(f"City: {row[0]}, Temperature: {row[1]}°F, Rank: {row[2]}")
```

**Result**: [('Houston', Decimal('90.10'), 1), ('Los Angeles', Decimal('85.20'), 2), ('New York', Decimal('72.50'), 3), ('Chicago', Decimal('68.30'), 4)]

**Explanation**: Demonstrates DuckDB's window function RANK() to create a temperature ranking across cities, showing how to use analytical functions with in-memory data
## Step 3: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create product inventory table
conn.execute('CREATE TABLE inventory (product_id INT, product_name TEXT, stock INT, price DECIMAL(10,2))')

# Insert sample inventory data
conn.executemany('INSERT INTO inventory VALUES (?, ?, ?, ?)', [
    (1, 'Laptop', 50, 1200.50),
    (2, 'Phone', 100, 800.25),
    (3, 'Tablet', 75, 600.00)
])

# Calculate total inventory value using SQL aggregation
result = conn.execute('''SELECT 
    SUM(stock * price) as total_inventory_value, 
    AVG(price) as average_product_price 
FROM inventory''').fetchone()

print(f'Total Inventory Value: ${result[0]}, Average Product Price: ${result[1]}')
```

**Result**: (Decimal('185050.00'), 866.9166666666666)

**Explanation**: Demonstrates creating an in-memory database, inserting inventory data, and performing aggregate calculations using SQL aggregation functions like SUM and AVG on a product inventory table.
## Step 4: # Create sales data

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales table with geographic dimension
conn.execute('CREATE TABLE regional_sales (region TEXT, product TEXT, sale_amount DECIMAL(10,2), sale_date DATE)')

# Insert diverse sales data with multiple dimensions
conn.executemany('INSERT INTO regional_sales VALUES (?, ?, ?, ?)', [
    ('West', 'Laptop', 1200.50, '2023-05-15'),
    ('East', 'Phone', 800.25, '2023-05-16'),
    ('Midwest', 'Tablet', 600.00, '2023-05-17'),
    ('South', 'Laptop', 1500.75, '2023-05-18'),
    ('West', 'Phone', 950.30, '2023-05-19')
])

# Analyze sales with advanced window and aggregation functions
result = conn.execute('''SELECT
    region,
    product,
    SUM(sale_amount) OVER (PARTITION BY region) as regional_total,
    RANK() OVER (ORDER BY sale_amount DESC) as sale_rank
FROM regional_sales
''').fetchall()

for row in result:
    print(f"Region: {row[0]}, Product: {row[1]}, Regional Total: ${row[2]}, Sale Rank: {row[3]}")
```

**Result**: [('South', 'Laptop', Decimal('1500.75'), 1), ('West', 'Laptop', Decimal('2150.80'), 2), ('West', 'Phone', Decimal('2150.80'), 3), ('East', 'Phone', Decimal('800.25'), 4), ('Midwest', 'Tablet', Decimal('600.00'), 5)]

**Explanation**: Demonstrates creating a multidimensional sales dataset with geographic segmentation, using window functions to calculate regional totals and sales rankings, showcasing DuckDB's advanced analytical capabilities.
## Step 5: con.execute('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a complex data tracking table for product reviews
conn.execute('''CREATE TABLE product_reviews (
    product_id INT,
    reviewer_id INT,
    rating DECIMAL(3,2),
    review_date DATE,
    helpful_votes INT
)''')

# Insert sample review data
conn.executemany('INSERT INTO product_reviews VALUES (?, ?, ?, ?, ?)', [
    (101, 1, 4.5, '2023-07-01', 25),
    (101, 2, 3.8, '2023-07-02', 15),
    (102, 3, 4.9, '2023-07-03', 40),
    (102, 4, 4.2, '2023-07-04', 20)
])

# Analyze reviews using window functions and aggregations
result = conn.execute('''SELECT
    product_id,
    ROUND(AVG(rating) OVER (PARTITION BY product_id), 2) as avg_product_rating,
    SUM(helpful_votes) OVER (PARTITION BY product_id) as total_helpful_votes,
    RANK() OVER (ORDER BY rating DESC) as rating_rank
FROM product_reviews
''').fetchall()

for row in result:
    print(f"Product ID: {row[0]}, Avg Rating: {row[1]}, Total Helpful Votes: {row[2]}, Rating Rank: {row[3]}")
```

**Result**: [(102, 4.55, 60, 1), (101, 4.15, 40, 2), (102, 4.55, 60, 3), (101, 4.15, 40, 4)]

**Explanation**: Demonstrates advanced window functions in DuckDB, showing how to perform complex analytical queries on product review data by computing aggregate metrics and rankings across different window partitions
## Step 6: CREATE TABLE sales AS

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales table using CREATE TABLE AS (CTAS)
conn.execute('''
CREATE TABLE sales AS
SELECT * FROM (
    VALUES
    ('Laptop', '2023-07-15', 1200.50),
    ('Phone', '2023-07-16', 800.25),
    ('Tablet', '2023-07-17', 600.00)
) AS t(product, sale_date, amount)
''')

# Verify table creation
result = conn.execute('SELECT * FROM sales').fetchall()
for row in result:
    print(row)
```

**Result**: [('Laptop', '2023-07-15', Decimal('1200.50')), ('Phone', '2023-07-16', Decimal('800.25')), ('Tablet', '2023-07-17', Decimal('600.00'))]

**Explanation**: Demonstrates DuckDB's CREATE TABLE AS (CTAS) syntax, creating a table directly from a VALUES clause, which allows inline data definition without separate INSERT statements. This approach is concise and useful for quick table generation with predefined data.
## Step 7: SELECT * FROM (VALUES

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a table using VALUES directly
result = conn.execute('''SELECT * FROM (VALUES 
    (1, 'Alice', 25),
    (2, 'Bob', 30),
    (3, 'Charlie', 35)
) AS people(id, name, age)''').fetchall()

for row in result:
    print(f'ID: {row[0]}, Name: {row[1]}, Age: {row[2]}')
```

**Result**: [(1, 'Alice', 25), (2, 'Bob', 30), (3, 'Charlie', 35)]

**Explanation**: Demonstrates using VALUES clause to create an inline table directly in a SELECT query, useful for quick data generation or testing without separate table creation
## Step 8: ('Electronics', 'Laptop', 1200),

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create electronics sales table
conn.execute('CREATE TABLE electronics_sales (category TEXT, product TEXT, sale_price DECIMAL(10,2))')

# Insert sample data
conn.executemany('INSERT INTO electronics_sales VALUES (?, ?, ?)', [
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Electronics', 'Tablet', 600)
])

# Query to show electronics sales with filtering
result = conn.execute(
    'SELECT category, product, sale_price FROM electronics_sales WHERE sale_price > 700'
).fetchall()

for row in result:
    print(f'Category: {row[0]}, Product: {row[1]}, Price: ${row[2]}')
```

**Result**: [('Electronics', 'Laptop', Decimal('1200.00')), ('Electronics', 'Phone', Decimal('800.00'))]

**Explanation**: Creates an in-memory electronics sales table, inserts sample data, and demonstrates basic filtering and retrieval of sales records above $700
## Step 9: ('Electronics', 'Phone', 800),

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create electronics catalog table
conn.execute('CREATE TABLE electronics (product_id INT, name TEXT, category TEXT, price DECIMAL(10,2))')

# Insert sample data
conn.executemany('INSERT INTO electronics VALUES (?, ?, ?, ?)', [
    (1, 'Smartphone', 'Mobile Devices', 799.99),
    (2, 'Laptop', 'Computers', 1299.50),
    (3, 'Tablet', 'Mobile Devices', 499.99)
])

# Query mobile devices above specified price threshold
result = conn.execute(
    'SELECT name, category, price FROM electronics WHERE category = ? AND price > ?', 
    ('Mobile Devices', 600)
).fetchall()

for product in result:
    print(f'Product: {product[0]}, Category: {product[1]}, Price: ${product[2]}')
```

**Result**: [('Smartphone', 'Mobile Devices', Decimal('799.99'))]

**Explanation**: Demonstrates creating an electronics catalog table, inserting data with parameterized insertion, and executing a filtered SQL query using parameter placeholders to retrieve mobile devices above a specific price threshold.
## Step 10: ('Electronics', 'Tablet', 500)

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create electronics catalog table
conn.execute('CREATE TABLE electronics (product_id INT, name TEXT, category TEXT, price DECIMAL(10,2))')

# Insert sample data
conn.executemany('INSERT INTO electronics VALUES (?, ?, ?, ?)', [
    (1, 'Smartphone', 'Electronics', 799.99),
    (2, 'Laptop', 'Electronics', 1299.50),
    (3, 'Tablet', 'Electronics', 499.99)
])

# Query specific electronics category with price filter
result = conn.execute(
    'SELECT name, category, price FROM electronics WHERE category = ? AND price >= ?', 
    ('Electronics', 500)
).fetchall()

for product in result:
    print(f'Product: {product[0]}, Category: {product[1]}, Price: ${product[2]}')
```

**Result**: [('Smartphone', 'Electronics', Decimal('799.99')), ('Laptop', 'Electronics', Decimal('1299.50'))]

**Explanation**: This code demonstrates DuckDB's filtering capabilities by creating an electronics catalog table and querying for products in the 'Electronics' category with a price at or above $500.
## Step 11: ) AS t(category, product, amount)

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales table using VALUES
sales_data = conn.execute('''
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200.50),
    ('Electronics', 'Phone', 800.25),
    ('Electronics', 'Tablet', 600.00)
) AS t(category, product, amount)
''').fetchall()

for row in sales_data:
    print(f'Category: {row[0]}, Product: {row[1]}, Amount: ${row[2]}')
```

**Result**: [('Smartphone', 'Electronics', Decimal('799.99')), ('Laptop', 'Electronics', Decimal('1299.50'))]

**Explanation**: Demonstrates creating an in-memory table directly via VALUES clause in DuckDB, allowing inline data definition without separate INSERT statements, with immediate querying and result processing.
## Step 12: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create time series transaction data
conn.execute('CREATE TABLE transactions (user_id INT, amount DECIMAL(10,2), timestamp TIMESTAMP)')

conn.executemany('INSERT INTO transactions VALUES (?, ?, ?)', [
    (1, 100.50, '2023-07-15 10:00:00'),
    (1, 250.75, '2023-07-15 11:30:00'),
    (2, 75.25, '2023-07-15 12:15:00'),
    (1, 325.00, '2023-07-15 13:45:00')
])

# Calculate user-level cumulative transaction metrics
result = conn.execute('''SELECT
    user_id,
    timestamp,
    amount,
    SUM(amount) OVER (PARTITION BY user_id ORDER BY timestamp) as cumulative_amount,
    AVG(amount) OVER (PARTITION BY user_id) as avg_transaction
FROM transactions
''').fetchall()

for row in result:
    print(f"User ID: {row[0]}, Time: {row[1]}, Amount: ${row[2]}, Cumulative: ${row[3]}, Avg Transaction: ${row[4]:.2f}")
```

**Result**: [(1, datetime.datetime(2023, 7, 15, 10, 0), Decimal('100.50'), Decimal('100.50'), 225.41666666666666), (1, datetime.datetime(2023, 7, 15, 11, 30), Decimal('250.75'), Decimal('351.25'), 225.41666666666666), (1, datetime.datetime(2023, 7, 15, 13, 45), Decimal('325.00'), Decimal('676.25'), 225.41666666666666), (2, datetime.datetime(2023, 7, 15, 12, 15), Decimal('75.25'), Decimal('75.25'), 75.25)]

**Explanation**: Demonstrates advanced time series analysis using DuckDB's window functions, calculating cumulative transaction amounts and average transaction values per user in a single query.
## Step 13: # Calculate running total per category

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales table
conn.execute('CREATE TABLE sales (category TEXT, amount DECIMAL(10,2), sale_date DATE)')

# Insert sample data
conn.executemany('INSERT INTO sales VALUES (?, ?, ?)', [
    ('Electronics', 1200.50, '2023-07-15'),
    ('Clothing', 500.25, '2023-07-16'),
    ('Electronics', 800.75, '2023-07-17'),
    ('Clothing', 350.00, '2023-07-18')
])

# Calculate running total per category
result = conn.execute('''SELECT
    category,
    sale_date,
    amount,
    SUM(amount) OVER (PARTITION BY category ORDER BY sale_date) as running_total
FROM sales
''').fetchall()

for row in result:
    print(f'Category: {row[0]}, Date: {row[1]}, Amount: ${row[2]}, Running Total: ${row[3]}')
```

**Result**: [('Electronics', datetime.date(2023, 7, 15), Decimal('1200.50'), Decimal('1200.50')), ('Electronics', datetime.date(2023, 7, 17), Decimal('800.75'), Decimal('2001.25')), ('Clothing', datetime.date(2023, 7, 16), Decimal('500.25'), Decimal('500.25')), ('Clothing', datetime.date(2023, 7, 18), Decimal('350.00'), Decimal('850.25'))]

**Explanation**: Demonstrates a DuckDB window function to calculate cumulative sales per product category, showing a running total that updates with each chronological sales record
## Step 14: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create user interactions tracking table
conn.execute('CREATE TABLE user_interactions (user_id INT, interaction_type TEXT, timestamp TIMESTAMP)')

# Insert sample interaction data
conn.executemany('INSERT INTO user_interactions VALUES (?, ?, ?)', [
    (1, 'Click', '2023-07-15 10:00:00'),
    (1, 'Purchase', '2023-07-15 11:30:00'),
    (2, 'View', '2023-07-15 12:15:00'),
    (1, 'Search', '2023-07-15 13:45:00')
])

# Analyze user interactions with advanced window functions
result = conn.execute('''SELECT
    user_id,
    interaction_type,
    timestamp,
    COUNT(*) OVER (PARTITION BY user_id) as total_interactions,
    FIRST_VALUE(interaction_type) OVER (PARTITION BY user_id ORDER BY timestamp) as first_interaction
FROM user_interactions
''').fetchall()

for row in result:
    print(f"User ID: {row[0]}, Type: {row[1]}, Time: {row[2]}, Total Interactions: {row[3]}, First Interaction: {row[4]}")
```

**Result**: [(1, 'Click', datetime.datetime(2023, 7, 15, 10, 0), 3, 'Click'), (1, 'Purchase', datetime.datetime(2023, 7, 15, 11, 30), 3, 'Click'), (1, 'Search', datetime.datetime(2023, 7, 15, 13, 45), 3, 'Click'), (2, 'View', datetime.datetime(2023, 7, 15, 12, 15), 1, 'View')]

**Explanation**: Demonstrates advanced window functions in DuckDB, tracking user interactions with total interaction count and first interaction tracking using partitioned window functions.
## Step 15: SELECT

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create and populate products table
conn.execute('CREATE TABLE products (id INT, name TEXT, price DECIMAL(10,2))')
conn.executemany('INSERT INTO products VALUES (?, ?, ?)', [
    (1, 'Laptop', 1200.50),
    (2, 'Phone', 800.25),
    (3, 'Tablet', 600.00)
])

# Demonstrate SELECT with complex filtering and projection
result = conn.execute(
    'SELECT name, price FROM products WHERE price > 700 ORDER BY price DESC'
).fetchall()

for product in result:
    print(f'Product: {product[0]}, Price: ${product[1]}')
```

**Result**: [('Laptop', Decimal('1200.50')), ('Phone', Decimal('800.25'))]

**Explanation**: Demonstrates a basic SELECT query in DuckDB with filtering (price > 700), ordering (DESC), and column projection, showing how to create an in-memory table and execute a simple query with multiple clauses
## Step 16: category,

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales tracking with multiple dimensions
conn.execute('CREATE TABLE advanced_sales (region TEXT, product TEXT, sale_date DATE, amount DECIMAL(10,2))')

conn.executemany('INSERT INTO advanced_sales VALUES (?, ?, ?, ?)', [
    ('West', 'Laptop', '2023-08-01', 1200.50),
    ('East', 'Phone', '2023-08-02', 800.25),
    ('Midwest', 'Tablet', '2023-08-03', 600.00)
])

# Demonstrate complex multi-dimensional analysis with window functions
result = conn.execute('''SELECT
    region,
    product,
    sale_date,
    amount,
    RANK() OVER (PARTITION BY region ORDER BY amount DESC) as regional_rank,
    SUM(amount) OVER (PARTITION BY region) as regional_total
FROM advanced_sales
''').fetchall()

for row in result:
    print(f'Region: {row[0]}, Product: {row[1]}, Date: {row[2]}, Amount: ${row[3]}, Regional Rank: {row[4]}, Regional Total: ${row[5]}')
```

**Result**: [('West', 'Laptop', datetime.date(2023, 8, 1), Decimal('1200.50'), 1, Decimal('1200.50')), ('East', 'Phone', datetime.date(2023, 8, 2), Decimal('800.25'), 1, Decimal('800.25')), ('Midwest', 'Tablet', datetime.date(2023, 8, 3), Decimal('600.00'), 1, Decimal('600.00'))]

**Explanation**: Demonstrates advanced DuckDB querying with multi-dimensional sales analysis using window functions to rank sales and calculate regional totals
## Step 17: product,

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create product sales tracking table
conn.execute('CREATE TABLE product_performance (product TEXT, sales_volume INT, unit_price DECIMAL(10,2))')

# Insert sample product data
conn.executemany('INSERT INTO product_performance VALUES (?, ?, ?)', [
    ('Laptop', 250, 1200.50),
    ('Phone', 500, 800.25),
    ('Tablet', 150, 600.00)
])

# Analyze product performance with advanced window functions
result = conn.execute('''SELECT
    product,
    sales_volume,
    unit_price,
    sales_volume * unit_price as total_revenue,
    RANK() OVER (ORDER BY sales_volume * unit_price DESC) as revenue_rank
FROM product_performance
''').fetchall()

for row in result:
    print(f'Product: {row[0]}, Sales Volume: {row[1]}, Unit Price: ${row[2]}, Total Revenue: ${row[3]}, Revenue Rank: {row[4]}')
```

**Result**: [('Phone', 500, Decimal('800.25'), Decimal('400125.00'), 1), ('Laptop', 250, Decimal('1200.50'), Decimal('300125.00'), 2), ('Tablet', 150, Decimal('600.00'), Decimal('90000.00'), 3)]

**Explanation**: This example demonstrates advanced product performance tracking using DuckDB, showcasing window functions, calculations, and multi-dimensional data analysis. It ranks products by total revenue using a calculated column and RANK() window function.
## Step 18: amount,

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a product sales tracking table
conn.execute('CREATE TABLE sales (product TEXT, quantity INT, price DECIMAL(10,2))')

# Insert sample sales data
conn.executemany('INSERT INTO sales VALUES (?, ?, ?)', [
    ('Laptop', 100, 1200.50),
    ('Phone', 250, 800.25),
    ('Tablet', 75, 600.00)
])

# Calculate total sales amount per product
result = conn.execute('''
    SELECT 
        product, 
        SUM(quantity * price) as total_revenue,
        AVG(price) as average_price
    FROM sales
    GROUP BY product
    ORDER BY total_revenue DESC
''').fetchall()

for row in result:
    print(f'Product: {row[0]}, Total Revenue: ${row[1]}, Avg Price: ${row[2]:.2f}')
```

**Result**: [('Phone', Decimal('200062.50'), 800.25), ('Laptop', Decimal('120050.00'), 1200.5), ('Tablet', Decimal('45000.00'), 600.0)]

**Explanation**: This example demonstrates DuckDB's capabilities for creating an in-memory table, inserting data, and performing aggregate calculations like SUM and AVG across product sales data, with results sorted by total revenue in descending order.
## Step 19: SUM(amount) OVER (PARTITION BY category ORDER BY amount) as running_total

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales table
conn.execute('CREATE TABLE sales (category TEXT, amount DECIMAL(10,2))')

# Insert sample data
conn.executemany('INSERT INTO sales VALUES (?, ?)', [
    ('Electronics', 1200.50),
    ('Clothing', 500.25),
    ('Electronics', 800.75),
    ('Clothing', 350.00)
])

# Calculate running total per category using window function
result = conn.execute('''SELECT
    category,
    amount,
    SUM(amount) OVER (PARTITION BY category ORDER BY amount) as running_total
FROM sales
''').fetchall()

for row in result:
    print(f'Category: {row[0]}, Amount: ${row[1]}, Running Total: ${row[2]}')
```

**Result**: [('Electronics', Decimal('800.75'), Decimal('800.75')), ('Electronics', Decimal('1200.50'), Decimal('2001.25')), ('Clothing', Decimal('350.00'), Decimal('350.00')), ('Clothing', Decimal('500.25'), Decimal('850.25'))]

**Explanation**: Demonstrates a window function that calculates a running total (cumulative sum) within each product category, ordered by the amount. Partitioning ensures the running total resets for each category, while ordering determines the cumulative calculation sequence.
## Step 20: FROM sales

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales table with dimensional data
conn.execute('CREATE TABLE sales (product TEXT, category TEXT, amount DECIMAL(10,2), sale_date DATE)')

# Insert sample sales data
conn.executemany('INSERT INTO sales VALUES (?, ?, ?, ?)', [
    ('Laptop', 'Electronics', 1200.50, '2023-07-15'),
    ('Phone', 'Electronics', 800.25, '2023-07-16'),
    ('Tablet', 'Electronics', 600.00, '2023-07-17'),
    ('Shirt', 'Clothing', 50.75, '2023-07-18')
])

# Perform multi-dimensional sales analysis
result = conn.execute('''
SELECT
    category,
    product,
    SUM(amount) as total_sales,
    AVG(amount) as average_sale
FROM sales
GROUP BY category, product
ORDER BY total_sales DESC
''').fetchall()

for row in result:
    print(f'Category: {row[0]}, Product: {row[1]}, Total Sales: ${row[2]}, Avg Sale: ${row[3]:.2f}')
```

**Result**: [('Electronics', 'Laptop', Decimal('1200.50'), 1200.5), ('Electronics', 'Phone', Decimal('800.25'), 800.25), ('Electronics', 'Tablet', Decimal('600.00'), 600.0), ('Clothing', 'Shirt', Decimal('50.75'), 50.75)]

**Explanation**: Demonstrates a comprehensive DuckDB query exploring sales data through multi-dimensional aggregation, showing total and average sales per product and category, with flexible grouping and ordering.
## Step 21: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a recursive common table expression (CTE) for generating a number series
result = conn.execute('''
WITH RECURSIVE number_series(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM number_series WHERE n < 10
)
SELECT n, n * n as squared FROM number_series
''').fetchall()

for row in result:
    print(f'Number: {row[0]}, Squared: {row[1]}')
```

**Result**: [(1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81), (10, 100)]

**Explanation**: Demonstrates DuckDB's support for recursive common table expressions (CTE) by generating a sequential number series and calculating squared values, showing how to create iterative queries using a recursive approach.
## Step 22: print(rel.execute().fetchall())```

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a sample table
conn.execute('CREATE TABLE numbers (value INT)')
conn.executemany('INSERT INTO numbers VALUES (?)', [(x,) for x in range(1, 11)])

# Filter and transform data
result = conn.execute('SELECT value, value * 2 as doubled FROM numbers WHERE value > 5').fetchall()

for row in result:
    print(f'Original: {row[0]}, Doubled: {row[1]}')
```

**Result**: [(6, 12), (7, 14), (8, 16), (9, 18), (10, 20)]

**Explanation**: Demonstrates basic DuckDB table creation, data insertion, filtering, and projection using SQL with a simple numbers transformation example.
