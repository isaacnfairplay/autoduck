# Task: I'll demonstrate DuckDB's array_transform function with a focused example showing numeric list transformation:

```python
import duckdb

con = duckdb.connect()

# Transform numeric array by squaring values
rel = con.query('''
SELECT array_transform([1, 2, 3, 4], x -> x * x) as squared_array
''')

print(rel.execute().fetchall())
```

This concise example showcases DuckDB's ability to apply functional transformations to lists directly within SQL queries, highlighting its flexible data manipulation capabilities.

## Step 1: I'll demonstrate DuckDB's array_transform function with a focused example showing numeric list transformation:

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Demonstrate array_transform for squaring list elements
result = conn.execute(
    "SELECT array_transform([1, 2, 3, 4, 5], x -> x * x) AS squared_list"
).fetchone()[0]

print(result)  # Output: [1, 4, 9, 16, 25]
```

**Result**: [1, 4, 9, 16, 25]

**Explanation**: Uses array_transform to apply a lambda function that squares each element of a numeric list, showcasing DuckDB's functional list manipulation capabilities.
## Step 2: ```python

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Complex example: Window functions with conditional ranking
conn.execute('''CREATE TABLE sales (
    product TEXT,
    region TEXT,
    amount DECIMAL(10,2)
)''')

conn.execute('''INSERT INTO sales VALUES
    ('Widget', 'North', 1000.50),
    ('Gadget', 'South', 1500.75),
    ('Widget', 'East', 800.25),
    ('Gadget', 'West', 1200.60),
    ('Widget', 'South', 950.30)''')

# Rank products within each region by sales amount
result = conn.execute('''SELECT
    product,
    region,
    amount,
    RANK() OVER (PARTITION BY region ORDER BY amount DESC) as regional_rank
FROM sales
''').fetchall()

for row in result:
    print(f"Product: {row[0]}, Region: {row[1]}, Amount: ${row[2]}, Regional Rank: {row[3]}")
```

**Result**: [('Gadget', 'South', Decimal('1500.75'), 1), ('Widget', 'South', Decimal('950.30'), 2), ('Gadget', 'West', Decimal('1200.60'), 1), ('Widget', 'North', Decimal('1000.50'), 1), ('Widget', 'East', Decimal('800.25'), 1)]

**Explanation**: Demonstrates window functions by ranking sales amounts within product regions, showing how DuckDB supports advanced analytical queries with partitioning and ranking capabilities.
## Step 3: import duckdb

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Nested subquery with lateral join demonstrating correlated aggregation
conn.execute('''CREATE TABLE departments (dept_id INT, dept_name TEXT)''')
conn.execute('''CREATE TABLE employees (emp_id INT, name TEXT, salary DECIMAL(10,2), dept_id INT)''')

conn.execute('''INSERT INTO departments VALUES (1, 'Sales'), (2, 'Engineering'), (3, 'Marketing')''')
conn.execute('''INSERT INTO employees VALUES 
    (101, 'Alice', 75000, 1), 
    (102, 'Bob', 85000, 1), 
    (103, 'Charlie', 95000, 2), 
    (104, 'David', 65000, 2), 
    (105, 'Eve', 55000, 3)''')

result = conn.execute('''
SELECT 
    d.dept_name, 
    avg_salary, 
    top_earner_name
FROM departments d
CROSS JOIN LATERAL (
    SELECT 
        AVG(salary) as avg_salary,
        MAX(name) as top_earner_name
    FROM employees e
    WHERE e.dept_id = d.dept_id
) dept_stats
''').fetchall()

for row in result:
    print(f"Department: {row[0]}, Avg Salary: ${row[1]:.2f}, Top Earner: {row[2]}")
```

**Result**: [('Engineering', 80000.0, 'David'), ('Sales', 80000.0, 'Bob'), ('Marketing', 55000.0, 'Eve')]

**Explanation**: Demonstrates a complex lateral join with correlated subquery, computing department-level salary statistics by dynamically aggregating employee data for each department
## Step 4: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Demonstrate temporal date functions and interval calculations
conn.execute('''CREATE TABLE events (
    event_date DATE,
    duration INTERVAL
)''')

conn.execute('''INSERT INTO events VALUES
    ('2023-01-15', INTERVAL 2 DAYS),
    ('2023-02-20', INTERVAL 1 WEEK),
    ('2023-03-25', INTERVAL 3 HOURS)''')

result = conn.execute('''
SELECT 
    event_date, 
    event_date + duration AS end_date,
    EXTRACT(EPOCH FROM duration) AS duration_seconds
FROM events
''').fetchall()

for row in result:
    print(f"Start: {row[0]}, End: {row[1]}, Duration: {row[2]} seconds")
```

**Result**: [(datetime.date(2023, 1, 15), datetime.datetime(2023, 1, 17, 0, 0), 172800.0), (datetime.date(2023, 2, 20), datetime.datetime(2023, 2, 27, 0, 0), 604800.0), (datetime.date(2023, 3, 25), datetime.datetime(2023, 3, 25, 3, 0), 10800.0)]

**Explanation**: Demonstrates DuckDB's temporal date manipulation capabilities, showing interval arithmetic, date addition, and epoch extraction in a single compact example
## Step 5: # Transform numeric array by squaring values

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Transform numeric array by squaring values
result = conn.execute(
    'SELECT array_transform([1, 2, 3, 4, 5], x -> x * x) AS squared_list'
).fetchone()[0]

print(result)  # Output: [1, 4, 9, 16, 25]
```

**Result**: [1, 4, 9, 16, 25]

**Explanation**: Demonstrates DuckDB's array_transform function to square each element in a numeric list using a lambda-like transformation.
## Step 6: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Demonstrate array filter with predicate
result = conn.execute(
    'SELECT array_filter([1, 2, 3, 4, 5], x -> x > 2) AS filtered_list'
).fetchone()[0]

print(result)  # Output: [3, 4, 5]
```

**Result**: [3, 4, 5]

**Explanation**: Shows array_filter() function filtering a numeric array by keeping only elements greater than 2, demonstrating DuckDB's inline lambda predicate capability
## Step 7: SELECT array_transform([1, 2, 3, 4], x -> x * x) as squared_array

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.execute('SELECT array_transform([1, 2, 3, 4], x -> x * x) as squared_array').fetchone()[0]
print(result)
```

**Result**: [1, 4, 9, 16]

**Explanation**: Demonstrates array_transform function to square each element in a numeric array using a lambda-like transformation
## Step 8: ''')

Failed after 3 attempts: Catalog Error: Type with name JSONB does not exist!
Did you mean "JSON"?
## Step 9: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
conn.execute('CREATE TABLE users (id INT, name STRING, age INT)')
conn.execute("INSERT INTO users VALUES (1, 'Alice', 30), (2, 'Bob', 25), (3, 'Charlie', 35)")

rel = conn.table('users').filter('age > 25')
print(rel.execute().fetchall())
```

**Result**: [1, 4, 9, 16]

**Explanation**: Creates an in-memory table of users, then uses the relational API to filter rows where age is greater than 25, demonstrating DuckDB's table filtering capabilities.
## Step 10: ```

Failed after 3 attempts: Binder Error: UNNEST not supported here

LINE 6: WHERE 'Python' IN (SELECT unnest(json_extract(data, '$.skills')))
                                  ^
## Step 11: This concise example showcases DuckDB's ability to apply functional transformations to lists directly within SQL queries, highlighting its flexible data manipulation capabilities.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Advanced array transformation with conditional mapping
result = conn.execute(
    'SELECT array_transform([1, 2, 3, 4, 5], x -> CASE WHEN x % 2 = 0 THEN x * x ELSE x + 10 END) AS transformed_list'
).fetchone()[0]

print(result)  # Output: [11, 4, 13, 16, 15]
```

**Result**: [11, 4, 13, 16, 15]

**Explanation**: Demonstrates DuckDB's array_transform function with a complex conditional mapping, showing how array elements can be transformed based on specific predicates within a single SQL expression.
