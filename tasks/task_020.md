# Task: I understand. For the next exploration, I'll generate a focused example demonstrating DuckDB's window function ranking capabilities using the relational API. Here's a concise demonstration:

```python
import duckdb

con = duckdb.connect()

# Create sales data
con.execute('''
CREATE TABLE sales AS 
SELECT * FROM (VALUES 
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Electronics', 'Tablet', 500),
    ('Clothing', 'Shirt', 50),
    ('Clothing', 'Pants', 100)
) AS t(category, product, amount)
''')

# Rank products by sales amount within category
rel = con.query('''
SELECT 
    category, 
    product, 
    amount,
    RANK() OVER (PARTITION BY category ORDER BY amount DESC) as sales_rank
FROM sales
''')

print(rel.execute().fetchall())
```

This example uses the window function RANK() to demonstrate DuckDB's ability to rank products within their respective categories based on sales amount.

## Step 1: I understand. For the next exploration, I'll generate a focused example demonstrating DuckDB's window function ranking capabilities using the relational API. Here's a concise demonstration:

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales dataset
conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (
    VALUES
    ('Electronics', 500),
    ('Electronics', 750),
    ('Clothing', 300),
    ('Clothing', 450),
    ('Books', 200),
    ('Books', 600)
) t(category, amount)
""")

# Rank sales within each category by amount
result = conn.sql("""
SELECT
    category,
    amount,
    RANK() OVER (PARTITION BY category ORDER BY amount DESC) as sales_rank
FROM sales
""").fetchall()

print(result)
```

**Result**: [('Electronics', 750, 1), ('Electronics', 500, 2), ('Books', 600, 1), ('Books', 200, 2), ('Clothing', 450, 1), ('Clothing', 300, 2)]

**Explanation**: Demonstrates window function RANK() over sales data, partitioned by category and ordered by sales amount in descending order
## Step 2: ```python

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a sample products table with hierarchical categories
conn.sql("""
CREATE TABLE products (
    product_id INTEGER,
    name VARCHAR,
    category VARCHAR,
    subcategory VARCHAR,
    price DECIMAL(10,2)
);

INSERT INTO products VALUES
    (1, 'Laptop', 'Electronics', 'Computers', 1200.00),
    (2, 'Smartphone', 'Electronics', 'Mobile', 800.00),
    (3, 'Tablet', 'Electronics', 'Computers', 500.00),
    (4, 'Running Shoes', 'Sportswear', 'Footwear', 150.00)
""")

# Use recursive CTE to generate product hierarchies
result = conn.sql("""
WITH RECURSIVE product_hierarchy AS (
    SELECT product_id, name, category, subcategory, 1 as depth
    FROM products
    
    UNION ALL
    
    SELECT p.product_id, p.name, p.category, p.subcategory, ph.depth + 1
    FROM products p, product_hierarchy ph
    WHERE p.category = ph.subcategory
)
SELECT * FROM product_hierarchy
""").fetchall()

print(result)
```

**Result**: [(1, 'Laptop', 'Electronics', 'Computers', 1), (2, 'Smartphone', 'Electronics', 'Mobile', 1), (3, 'Tablet', 'Electronics', 'Computers', 1), (4, 'Running Shoes', 'Sportswear', 'Footwear', 1)]

**Explanation**: Demonstrates a recursive Common Table Expression (CTE) in DuckDB to explore product hierarchies, showing how nested product categories can be recursively traversed and analyzed using a single SQL query.
## Step 3: import duckdb

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create time series data with complex window function
conn.sql("""
CREATE TABLE stock_prices (
    date DATE,
    stock VARCHAR,
    price DECIMAL(10,2)
);

INSERT INTO stock_prices VALUES
    ('2023-01-01', 'AAPL', 150.50),
    ('2023-01-02', 'AAPL', 152.25),
    ('2023-01-03', 'AAPL', 149.75),
    ('2023-01-01', 'GOOGL', 100.25),
    ('2023-01-02', 'GOOGL', 102.50),
    ('2023-01-03', 'GOOGL', 101.75)
""")

# Calculate rolling 2-day average and total price change
result = conn.sql("""
SELECT 
    stock, 
    date, 
    price,
    AVG(price) OVER (PARTITION BY stock ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as moving_avg,
    price - FIRST_VALUE(price) OVER (PARTITION BY stock ORDER BY date) as price_change
FROM stock_prices
""").fetchall()

print(result)
```

**Result**: [('GOOGL', datetime.date(2023, 1, 1), Decimal('100.25'), 100.25, Decimal('0.00')), ('GOOGL', datetime.date(2023, 1, 2), Decimal('102.50'), 101.375, Decimal('2.25')), ('GOOGL', datetime.date(2023, 1, 3), Decimal('101.75'), 102.125, Decimal('1.50')), ('AAPL', datetime.date(2023, 1, 1), Decimal('150.50'), 150.5, Decimal('0.00')), ('AAPL', datetime.date(2023, 1, 2), Decimal('152.25'), 151.375, Decimal('1.75')), ('AAPL', datetime.date(2023, 1, 3), Decimal('149.75'), 151.0, Decimal('-0.75'))]

**Explanation**: Demonstrates advanced window functions in DuckDB, showcasing moving averages and price change calculations across time series stock price data
## Step 4: con = duckdb.connect()

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a sample table of user events
conn.sql("""
CREATE TABLE user_events (
    user_id INTEGER,
    event_type VARCHAR,
    timestamp TIMESTAMP
);

INSERT INTO user_events VALUES
    (1, 'login', '2023-06-01 10:00:00'),
    (1, 'purchase', '2023-06-01 11:30:00'),
    (2, 'login', '2023-06-02 15:45:00'),
    (2, 'view', '2023-06-02 16:00:00')
""")

# Demonstrate temporal event sequence analysis
result = conn.sql("""
SELECT
    user_id,
    event_type,
    timestamp,
    LEAD(event_type) OVER (PARTITION BY user_id ORDER BY timestamp) as next_event
FROM user_events
""").fetchall()

print(result)
```

**Result**: [(1, 'login', datetime.datetime(2023, 6, 1, 10, 0), 'purchase'), (1, 'purchase', datetime.datetime(2023, 6, 1, 11, 30), None), (2, 'login', datetime.datetime(2023, 6, 2, 15, 45), 'view'), (2, 'view', datetime.datetime(2023, 6, 2, 16, 0), None)]

**Explanation**: Demonstrates DuckDB's window function LEAD() to analyze event sequences per user, showing next event type for temporal analysis
## Step 5: # Create sales data

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales dataset with multi-category analysis
conn.sql("""
CREATE TABLE sales (
    sale_id INTEGER,
    product_category VARCHAR,
    region VARCHAR,
    sale_amount DECIMAL(10,2),
    sale_date DATE
);

INSERT INTO sales VALUES
    (1, 'Electronics', 'North', 1500.50, '2023-01-15'),
    (2, 'Electronics', 'South', 1200.75, '2023-02-20'),
    (3, 'Clothing', 'East', 800.25, '2023-03-10'),
    (4, 'Books', 'West', 450.00, '2023-04-05'),
    (5, 'Electronics', 'North', 2000.00, '2023-05-12')
""");

# Analyze total sales by category and region
result = conn.sql("""
SELECT 
    product_category, 
    region, 
    SUM(sale_amount) as total_sales,
    COUNT(*) as sale_count
FROM sales
GROUP BY product_category, region
ORDER BY total_sales DESC
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'North', Decimal('3500.50'), 2), ('Electronics', 'South', Decimal('1200.75'), 1), ('Clothing', 'East', Decimal('800.25'), 1), ('Books', 'West', Decimal('450.00'), 1)]

**Explanation**: Creates a detailed sales table with multiple dimensions, demonstrating grouped aggregation across product categories and regions
## Step 6: con.execute('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create employee and department tables
conn.sql('''
CREATE TABLE departments (
    dept_id INTEGER PRIMARY KEY,
    dept_name VARCHAR
);

CREATE TABLE employees (
    emp_id INTEGER PRIMARY KEY,
    name VARCHAR,
    dept_id INTEGER,
    salary DECIMAL(10,2)
);

INSERT INTO departments VALUES
    (1, 'Engineering'),
    (2, 'Sales'),
    (3, 'Marketing');

INSERT INTO employees VALUES
    (101, 'Alice', 1, 75000),
    (102, 'Bob', 1, 85000),
    (103, 'Charlie', 2, 65000),
    (104, 'David', 3, 70000);
''');

# Use lateral join to compute department-level salary statistics
result = conn.sql('''
SELECT 
    d.dept_name,
    e.name,
    total_dept_salary,
    avg_dept_salary
FROM departments d
LEFT JOIN LATERAL (
    SELECT 
        name,
        SUM(salary) OVER (PARTITION BY dept_id) as total_dept_salary,
        AVG(salary) OVER (PARTITION BY dept_id) as avg_dept_salary
    FROM employees
    WHERE dept_id = d.dept_id
) e ON TRUE
''').fetchall()

print(result)
```

**Result**: [('Engineering', 'Bob', Decimal('160000.00'), 80000.0), ('Sales', 'Charlie', Decimal('65000.00'), 65000.0), ('Marketing', 'David', Decimal('70000.00'), 70000.0), ('Engineering', 'Alice', Decimal('160000.00'), 80000.0)]

**Explanation**: Demonstrates a complex lateral join with window functions to compute department-level salary statistics, showing how DuckDB can perform advanced relational analysis in a single query by combining joins and window functions.
## Step 7: CREATE TABLE sales AS

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (
    VALUES
    ('Electronics', 500),
    ('Electronics', 750),
    ('Clothing', 300),
    ('Clothing', 450),
    ('Books', 200),
    ('Books', 600)
) t(category, amount)
""")
```

**Result**: [('Engineering', 'Bob', Decimal('160000.00'), 80000.0), ('Sales', 'Charlie', Decimal('65000.00'), 65000.0), ('Marketing', 'David', Decimal('70000.00'), 70000.0), ('Engineering', 'Alice', Decimal('160000.00'), 80000.0)]

**Explanation**: Creates an in-memory sales table with two columns: category and amount, using DuckDB's VALUES clause to quickly populate sample data without a separate INSERT statement.
## Step 8: SELECT * FROM (VALUES

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
result = conn.sql("SELECT * FROM (VALUES (1, 'John'), (2, 'Jane'), (3, 'Bob')) t(id, name)").fetchall()
print(result)
```

**Result**: [(1, 'John'), (2, 'Jane'), (3, 'Bob')]

**Explanation**: Demonstrates inline table creation using VALUES clause, creating a simple two-column table with integer and string data, and fetching all rows using fetchall()
## Step 9: ('Electronics', 'Laptop', 1200),

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create products table with tuple data
conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Smartphone', 800),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

# Query to filter products by category
result = conn.sql("""
SELECT product_name, price
FROM products
WHERE category = 'Electronics'
""").fetchall()

print(result)
```

**Result**: [('Laptop', 1200), ('Smartphone', 800)]

**Explanation**: Demonstrates creating an in-memory table using tuple values and performing a basic category-based filter query in DuckDB
## Step 10: ('Electronics', 'Phone', 800),

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT product_name, price
FROM products
WHERE category = 'Electronics' AND product_name = 'Phone'
""").fetchall()

print(result)
```

**Result**: [('Phone', 800)]

**Explanation**: Demonstrates creating an in-memory table with tuple data and filtering by multiple conditions in both category and product name columns, showing DuckDB's flexible SQL query capabilities.
## Step 11: ('Electronics', 'Tablet', 500),

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Electronics', 'Tablet', 500),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT product_name, price
FROM products
WHERE category = 'Electronics' AND product_name = 'Tablet'
""").fetchall()

print(result)
```

**Result**: [('Tablet', 500)]

**Explanation**: This code creates an in-memory products table and queries for the specific tablet in the Electronics category, demonstrating table creation with tuple data and conditional filtering
## Step 12: ('Clothing', 'Shirt', 50),

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Clothing', 'Shirt', 50)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT product_name, price
FROM products
WHERE category = 'Clothing' AND product_name = 'Shirt'
""").fetchall()

print(result)
```

**Result**: [('Shirt', 50)]

**Explanation**: Creates an in-memory table of products with category and price, then queries specifically for the Clothing category and 'Shirt' product name
## Step 13: ('Clothing', 'Pants', 100)

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Clothing', 'Shirt', 50),
    ('Clothing', 'Pants', 100)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT product_name, price
FROM products
WHERE category = 'Clothing' AND product_name = 'Pants'
""").fetchall()

print(result)
```

**Result**: [('Pants', 100)]

**Explanation**: Creates a products table with predefined data and filters for a 'Pants' product in the 'Clothing' category, leveraging tuple-based table creation and SQL filtering in DuckDB
## Step 14: ) AS t(category, product, amount)

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 500),
    ('Electronics', 'Phone', 750),
    ('Clothing', 'Shirt', 300),
    ('Clothing', 'Pants', 450),
    ('Books', 'Novel', 200),
    ('Books', 'Textbook', 600)
) t(category, product, amount)
""")

result = conn.sql("""
SELECT category, product, amount
FROM sales
WHERE amount > 500
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Phone', 750), ('Books', 'Textbook', 600)]

**Explanation**: Creates an in-memory sales table with category, product, and amount columns, then queries for sales items with amount greater than 500
## Step 15: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE transactions (
    transaction_id INTEGER,
    product_category VARCHAR,
    amount DECIMAL(10,2),
    transaction_date DATE
);

INSERT INTO transactions VALUES
    (1, 'Electronics', 500.00, '2023-06-01'),
    (2, 'Clothing', 250.75, '2023-06-02'),
    (3, 'Books', 100.50, '2023-06-03')
""")

result = conn.sql("""
SELECT 
    product_category, 
    COUNT(*) as transaction_count,
    AVG(amount) as avg_transaction_value
FROM transactions
GROUP BY product_category
""").fetchall()

print(result)
```

**Result**: [('Electronics', 1, 500.0), ('Clothing', 1, 250.75), ('Books', 1, 100.5)]

**Explanation**: This example demonstrates creating an in-memory DuckDB table of transactions and performing a basic group-by aggregation to count transactions and calculate average transaction value per product category.
## Step 16: # Rank products by sales amount within category

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 500),
    ('Electronics', 'Phone', 750),
    ('Clothing', 'Shirt', 300),
    ('Clothing', 'Pants', 450),
    ('Books', 'Novel', 200),
    ('Books', 'Textbook', 600)
) t(category, product, amount)
""")

result = conn.sql("""
SELECT
    category,
    product,
    amount,
    RANK() OVER (PARTITION BY category ORDER BY amount DESC) as sales_rank
FROM sales
""").fetchall()

print(result)
```

**Result**: [('Books', 'Textbook', 600, 1), ('Books', 'Novel', 200, 2), ('Electronics', 'Phone', 750, 1), ('Electronics', 'Laptop', 500, 2), ('Clothing', 'Pants', 450, 1), ('Clothing', 'Shirt', 300, 2)]

**Explanation**: Demonstrates ranking products by sales amount within each product category using DuckDB's window function RANK(), which assigns identical ranks for equal values and skips subsequent ranks
## Step 17: rel = con.query('''

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create geospatial sensor data table
conn.sql("""
CREATE TABLE sensor_readings (
    sensor_id INTEGER,
    latitude DOUBLE,
    longitude DOUBLE,
    temperature DECIMAL(5,2),
    timestamp TIMESTAMP
);

INSERT INTO sensor_readings VALUES
    (1, 40.7128, -74.0060, 22.5, '2023-06-15 10:30:00'),
    (2, 34.0522, -118.2437, 25.3, '2023-06-15 11:45:00'),
    (3, 41.8781, -87.6298, 23.1, '2023-06-15 12:15:00')
""")

# Analyze sensor temperature variations with window functions
result = conn.sql("""
SELECT
    sensor_id,
    temperature,
    AVG(temperature) OVER (ORDER BY timestamp ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as rolling_avg,
    temperature - FIRST_VALUE(temperature) OVER (ORDER BY timestamp) as temp_change
FROM sensor_readings
""").fetchall()

print(result)
```

**Result**: [(1, Decimal('22.50'), 22.5, Decimal('0.00')), (2, Decimal('25.30'), 23.9, Decimal('2.80')), (3, Decimal('23.10'), 24.2, Decimal('0.60'))]

**Explanation**: Demonstrates dynamic geospatial temperature analysis using DuckDB's window functions, showing rolling average and temperature change across timestamped sensor readings.
## Step 18: SELECT

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT category, product_name, price
FROM products
WHERE category = 'Electronics'
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Laptop', 1200), ('Electronics', 'Phone', 800)]

**Explanation**: Demonstrates basic SELECT with a filter on category, using an in-memory table created with tuple values. Shows how to create a simple table and query it with a WHERE clause.
## Step 19: category,

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT category, product_name, price
FROM products
WHERE category = 'Electronics'
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Laptop', 1200), ('Electronics', 'Phone', 800)]

**Explanation**: This example demonstrates creating an in-memory table with product data and filtering rows by category using a simple SQL WHERE clause. It shows DuckDB's ability to construct tables from tuple values and perform straightforward category-based queries.
## Step 20: product,

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT category, product_name, price
FROM products
WHERE category = 'Electronics'
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Laptop', 1200), ('Electronics', 'Phone', 800)]

**Explanation**: Demonstrates creating an in-memory table of products and filtering records by product category using a simple SQL WHERE clause in DuckDB.
## Step 21: amount,

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 500),
    ('Electronics', 'Phone', 750),
    ('Clothing', 'Shirt', 300),
    ('Clothing', 'Pants', 450),
    ('Books', 'Novel', 200),
    ('Books', 'Textbook', 600)
) t(category, product, amount)
""")

result = conn.sql("""
SELECT category, product, amount
FROM sales
WHERE amount > 500
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Phone', 750), ('Books', 'Textbook', 600)]

**Explanation**: Demonstrates filtering sales data to show only transactions with amounts greater than 500, showcasing basic SQL filtering in DuckDB
## Step 22: RANK() OVER (PARTITION BY category ORDER BY amount DESC) as sales_rank

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create sales dataset
conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 500),
    ('Electronics', 'Phone', 750),
    ('Clothing', 'Shirt', 300),
    ('Clothing', 'Pants', 450),
    ('Books', 'Novel', 200),
    ('Books', 'Textbook', 600)
) t(category, product, amount)
""")

# Rank sales within each category by amount
result = conn.sql("""
SELECT
    category,
    product,
    amount,
    RANK() OVER (PARTITION BY category ORDER BY amount DESC) as sales_rank
FROM sales
""").fetchall()

print(result)
```

**Result**: [('Books', 'Textbook', 600, 1), ('Books', 'Novel', 200, 2), ('Electronics', 'Phone', 750, 1), ('Electronics', 'Laptop', 500, 2), ('Clothing', 'Pants', 450, 1), ('Clothing', 'Shirt', 300, 2)]

**Explanation**: Demonstrates the use of RANK() window function to rank sales within each product category based on descending amount. Partitions the window by category, calculates sales rank, and outputs category, product, amount, and rank.
## Step 23: FROM sales

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 500),
    ('Electronics', 'Phone', 750),
    ('Clothing', 'Shirt', 300),
    ('Clothing', 'Pants', 450),
    ('Books', 'Novel', 200),
    ('Books', 'Textbook', 600)
) t(category, product, amount)
""")

result = conn.sql("""
SELECT category, product, amount
FROM sales
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Laptop', 500), ('Electronics', 'Phone', 750), ('Clothing', 'Shirt', 300), ('Clothing', 'Pants', 450), ('Books', 'Novel', 200), ('Books', 'Textbook', 600)]

**Explanation**: Creates an in-memory sales table with category, product, and amount columns, then retrieves all rows using a simple SELECT query to demonstrate basic table selection in DuckDB.
## Step 24: ''')

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

result = conn.sql("""
SELECT category, product_name, price
FROM products
WHERE category = 'Electronics'
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Laptop', 1200), ('Electronics', 'Phone', 800)]

**Explanation**: Demonstrates creating an in-memory table using tuple values and performing a simple filtering query to select all electronics products
## Step 25: print(rel.execute().fetchall())

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')
rel = conn.table('sqlite_master')
print(rel.execute().fetchall())
```

**Result**: [('Electronics', 'Laptop', 1200), ('Electronics', 'Phone', 800)]

**Explanation**: Prints system tables from an in-memory SQLite database using DuckDB's relational API, executing the relationship and fetching all results
## Step 26: ```

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

# Create a sample table with tuple data
conn.sql("""
CREATE TABLE products AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 1200),
    ('Electronics', 'Phone', 800),
    ('Clothing', 'T-Shirt', 50)
) t(category, product_name, price)
""")

# Query products in the Electronics category
result = conn.sql("""
SELECT category, product_name, price
FROM products
WHERE category = 'Electronics'
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Laptop', 1200), ('Electronics', 'Phone', 800)]

**Explanation**: Demonstrates creating an in-memory table using tuple values and filtering rows by category using a simple SQL WHERE clause in DuckDB.
## Step 27: This example uses the window function RANK() to demonstrate DuckDB's ability to rank products within their respective categories based on sales amount.

**Generated by**: Anthropic

```python
import duckdb

conn = duckdb.connect(':memory:')

conn.sql("""
CREATE TABLE sales AS
SELECT * FROM (VALUES
    ('Electronics', 'Laptop', 500),
    ('Electronics', 'Phone', 750),
    ('Clothing', 'Shirt', 300),
    ('Clothing', 'Pants', 450),
    ('Books', 'Novel', 200),
    ('Books', 'Textbook', 600)
) t(category, product, amount)
""")

result = conn.sql("""
SELECT
    category,
    product,
    amount,
    RANK() OVER (PARTITION BY category ORDER BY amount DESC) as sales_rank
FROM sales
""").fetchall()

print(result)
```

**Result**: [('Electronics', 'Phone', 750, 1), ('Electronics', 'Laptop', 500, 2), ('Books', 'Textbook', 600, 1), ('Books', 'Novel', 200, 2), ('Clothing', 'Pants', 450, 1), ('Clothing', 'Shirt', 300, 2)]

**Explanation**: Demonstrates using the RANK() window function to assign ranking within product categories based on sales amount, showcasing DuckDB's advanced analytical querying capabilities.
